

PCLF Language

The PCLF Language (PCLF Lang) is a simple embedded domain-specific language for use in template files.

Some examples:

record(ai, $(INSTALLATION_SLOT):InRegister1) {
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP, "@$(PLCNAME)/$[PLCF#PropertyInteger02] T=WORD")
}



An expression in PCLF_Lang is tagged in the following way of the format:

  $[PLCF# <expression> ]


Examples:


$[PLCF#10*4] T=WORD")

$[PLCF#PropertyInteger02+PropertyInteger02] T=WORD")

$[PLCF#PropertyInteger02+4] T=WORD")

$[PLCF#4+PropertyInteger02] T=WORD")

Note that the user has to take responsibility for writing valid expressions. There is only basic feedback for erroneous input.


Variables are simply replaced:

$[PLCF#PropertyString01]


Variables must be part of the corresponding property entries in CCDB.


Advanced: Defining your own functions:

$[PLCF#ext.foo(PropertyInteger02)] T=WORD")

$[PLCF#ext.foo(ext.foo(PropertyInteger02+10))] T=WORD")


The function foo is defined in pclflang_extensions.py:

def foo(x):
    return x * x * x


You can define your own functions, using Python, by adding them to this file. Those functions can be called with the prefix 'ext'. For instance, if you defined the function 'bar()' in pclflang_extensions.py, you would call it in PLCF_Lang as follows:

$[PLCF#ext.bar()+10))]

If 'bar()' takes an argument, write for instance:

$[PLCF#ext.bar(4)+10))]

or

$[PLCF#ext.bar(PropertyInteger02)+10))]






INSTALLATION_SLOT

there is no need to change the code if the desired behavior is to not replace INSTALLATION_SLOT within a PLCF expression. For instance, a line like this:

    field(INP, "@$(PLCNAME)/$[PLCF#$(INSTALLATION_SLOT)] T=WORD")

...is turned into:

    field(INP, "@LNS-ISrc-01:Vac-PGV-1/$(INSTALLATION_SLOT) T=WORD")

The PLCF tag is peeled off, but the expression is unchanged otherwise.






Basic sanity checks are included:
 - an opening square bracket has to be followed by a closing square bracket
 - parentheses need to match