FUNCTION_BLOCK "_UtilitiesFB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      CPUSytemMemoryBits { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Byte;   // Address of system memory byte
      CPUClockMemoryBits { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Byte;   // Address of clock memory byte
      StartupDelaySP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;   // Delay before startup delay bit turned on
   END_VAR

   VAR 
      AlwaysOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always TRUE
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always TRUE
      AlwaysOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always FALSE
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always FALSE
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE for only the first scan of the PLC
      StartupDelayDn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit initially FALSE, turning TRUE after preset delay
      StartupDelayTmr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      Square_100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (100 ms frequency)
      Square_100msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 100 ms for one PLC scan
      Square_200ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (200 ms frequency)
      Square_200msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_200ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 200 ms for one PLC scan
      Square_400ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (400 ms frequency)
      Square_400msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_400ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 400 ms for one PLC scan
      Square_500ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (500 ms frequency)
      Square_500msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_500ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 500 ms for one PLC scan
      Square_800ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (800 ms frequency)
      Square_800msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_800ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 800 ms for one PLC scan
      Square_1s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (1 s frequency)
      Square_1sONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_1s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 1 s for one PLC scan
      Square_1600ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (1600 ms frequency)
      Square_1600msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_1600ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 1600 ms for one PLC scan
      Square_2s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (2 s frequency)
      Square_2sONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_2s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 2 s for one PLC scan
      TestInProgress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Indicates which caller FC is used
      EPICS_Device_calls_precessed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Indicates which caller FC is used
      EPICSParametersStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;   // 0=Never Uploaded 1=Uploading... 2=Uploaded
   END_VAR
   VAR RETAIN
      ParameterFreeze { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // If True, the Handlers doesn't take new parameters from EPICS
   END_VAR

BEGIN
	//This block provides standard "Utilities" tags that can be used in the rest OF the PLC code such
	//as:
	//* Always On
	//* Always Off
	//* Startup Delay
	//* Pulses (different frequences)
	//* etc.

	//When using This block in your program, name the instance DB "Utilities" AND THEN you will be able TO use tags like "Utilities.AlwaysOn" in the rest OF your program.

	//This block relies On information provided BY the CPU. This needs TO be enabled in the CPU hardware configuration under System AND Clock Memory.
	//Enable both functions AND pick memory bytes you'd like TO use (defauls are %MB1 AND %MB0 respectively).
	//THEN connect the selected Byte TO the inputs OF This block.
	//

	//Bit TRUE for only the first scan of the PLC
	#FirstScan := #CPUSytemMemoryBits.%X0;

	//Bit always TRUE
	#AlwaysOn := #CPUSytemMemoryBits.%X2;
	#AlwaysTrue := #CPUSytemMemoryBits.%X2;

	//Bit always FALSE
	#AlwaysOff := #CPUSytemMemoryBits.%X3;
	#AlwaysFalse := #CPUSytemMemoryBits.%X3;

	//Bit initially FALSE, turning TRUE after preset delay
	#StartupDelayTmr.TON(IN := #AlwaysTrue,
	                     PT := #StartupDelaySP,
	                     Q => #StartupDelayDn);

	//Bit TRUE every 100 ms FOR one PLC scan
	#Square_100ms := #CPUClockMemoryBits.%X0;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_100ms,
	              "iq_Trigger Bit" := #Square_100msONS,
	              "iq_Pulse Bit" := #Pulse_100ms);

	//Bit TRUE every 200 ms FOR one PLC scan
	#Square_200ms := #CPUClockMemoryBits.%X1;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_200ms,
	              "iq_Trigger Bit" := #Square_200msONS,
	              "iq_Pulse Bit" := #Pulse_200ms);

	//Bit TRUE every 400 ms FOR one PLC scan
	#Square_400ms := #CPUClockMemoryBits.%X2;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_400ms,
	              "iq_Trigger Bit" := #Square_400msONS,
	              "iq_Pulse Bit" := #Pulse_400ms);

	//Bit TRUE every 500 ms FOR one PLC scan
	#Square_500ms := #CPUClockMemoryBits.%X3;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_500ms,
	              "iq_Trigger Bit" := #Square_500msONS,
	              "iq_Pulse Bit" := #Pulse_500ms);

	//Bit TRUE every 800 ms FOR one PLC scan
	#Square_800ms := #CPUClockMemoryBits.%X4;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_800ms,
	              "iq_Trigger Bit" := #Square_800msONS,
	              "iq_Pulse Bit" := #Pulse_800ms);

	//Bit TRUE every 1 s FOR one PLC scan
	#Square_1s := #CPUClockMemoryBits.%X5;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_1s,
	              "iq_Trigger Bit" := #Square_1sONS,
	              "iq_Pulse Bit" := #Pulse_1s);

	//Bit TRUE every 1600 ms FOR one PLC scan
	#Square_1600ms := #CPUClockMemoryBits.%X6;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_1600ms,
	              "iq_Trigger Bit" := #Square_1600msONS,
	              "iq_Pulse Bit" := #Pulse_1600ms);

	//Bit TRUE every 2s FOR one PLC scan
	#Square_2s := #CPUClockMemoryBits.%X7;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_2s,
	              "iq_Trigger Bit" := #Square_2sONS,
	              "iq_Pulse Bit" := #Pulse_2s);

END_FUNCTION_BLOCK
DATA_BLOCK "Utilities"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"_UtilitiesFB"

BEGIN
   ParameterFreeze := true;
END_DATA_BLOCK
FUNCTION_BLOCK "DEVTYPE_C3S_AUTO_CONF"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "Controlled_Device" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: Controlled_Device
      "Controlled_Dev_Msg" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: Controlled_Dev_Msg
      "OpMode" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: OpMode
      "OpMode_Msg" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: OpMode_Msg
      "SS_ON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: SS_ON
      "SS_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: SS_Setpoint
      "Measuring_Device" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: Measuring_Device
      "Measuring_Dev_Msg" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: Measuring_Dev_Msg
      "INT_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: INT_Setpoint
      "LowLimit" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: LowLimit
      "HighLimit" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: HighLimit
      "Config_Fault" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Config_Fault
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_Get_Data" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Get_Data
      "Cmd_Set_Data" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Set_Data
      "Cmd_Enable_AutoConf" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Enable_AutoConf
      "Cmd_Disable_AutoConf" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Disable_AutoConf
      "P_Ctrld_Dev_Index" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: P_Ctrld_Dev_Index
      "P_Ctrld_Dev_Name" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Parameter variable: P_Controled_Dev_Name
      "P_OpMode_Index" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: P_OpMode_Index
      "P_OpMode_Name" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Parameter variable: P_OpMode_Name
      "P_SS_ON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Parameter variable: P_SS_ON
      "P_SS_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_SS_Setpoint
      "P_Meas_Dev_Index" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: P_Meas_Dev_Index
      "P_Meas_Dev_Name" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Parameter variable: P_Measuring_Dev_Name
      "P_INT_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_INT_Setpoint
      "P_LowLimit" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_LowLimit
      "P_HighLimit" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_HighLimit
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: C3S_AUTO_CONF
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //#############################################################################################
       //CONFIGURATION INTERFACE FOR
       //#############################################################################################
       //Author:   ZMa
       //Date:	    14-01-2020
       //Version:  v1.1
       //Note:
       //#############################################################################################
       //Author:   EAsensi
       //Date:	    26-01-2021
       //Version:  v1.2
       //Note: Shortened names for EPICS
       //#############################################################################################
       //###########################
       //STATUS BLOCK
       //###########################
       //OPI buttons

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyInt := #"Controlled_Device";    //EPICSName: Controlled_Device
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWordinInt;

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"Controlled_Dev_Msg";  //EPICSName: Controlled_Dev_Msg
       FOR #i:=0 TO 18 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1 + 19] := #MyWordsinString[20] & 16#FF00;

       #MyInt := #"OpMode";    //EPICSName: OpMode
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 21] := #MyWordinInt;

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"OpMode_Msg";  //EPICSName: OpMode_Msg
       FOR #i:=0 TO 18 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 22 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 22 + 19] := #MyWordsinString[20] & 16#FF00;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"SS_ON";    //EPICSName: SS_ON
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 42] := #MyWord;

       #MyReal := #"SS_Setpoint";    //EPICSName: SS_Setpoint
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 43] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 44] := #MyWordsinReal[1];

       #MyInt := #"Measuring_Device";    //EPICSName: Measuring_Device
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 45] := #MyWordinInt;

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"Measuring_Dev_Msg";  //EPICSName: Measuring_Dev_Msg
       FOR #i:=0 TO 18 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 46 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 46 + 19] := #MyWordsinString[20] & 16#FF00;

       #MyReal := #"INT_Setpoint";    //EPICSName: INT_Setpoint
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 66] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 67] := #MyWordsinReal[1];

       #MyReal := #"LowLimit";    //EPICSName: LowLimit
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 68] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 69] := #MyWordsinReal[1];

       #MyReal := #"HighLimit";    //EPICSName: HighLimit
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 70] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 71] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Config_Fault";    //EPICSName: Config_Fault
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 72] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_Get_Data" := #MyBoolsinWord[8];    //EPICSName: Cmd_Get_Data
       #"Cmd_Set_Data" := #MyBoolsinWord[9];    //EPICSName: Cmd_Set_Data
       #"Cmd_Enable_AutoConf" := #MyBoolsinWord[10];    //EPICSName: Cmd_Enable_AutoConf
       #"Cmd_Disable_AutoConf" := #MyBoolsinWord[11];    //EPICSName: Cmd_Disable_AutoConf

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #"P_Ctrld_Dev_Index" := #MyInt;    //EPICSName: P_Ctrld_Dev_Index

       #i := 0;
       WHILE TRUE DO
            IF #i = 20 THEN
                 #i := 39;
                 EXIT;
            END_IF;
            #MyWordsinString[#i + 1] := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2 + #i];
            //Check if there is a terminating zero and store the string length in bytes
            IF (#MyWordsinString[#i + 1] & 16#FF00) = 0 THEN
                 #i := #i * 2;
                 EXIT;
            ELSIF (#MyWordsinString[#i + 1] & 16#00FF) = 0 THEN
                 #i := #i * 2 + 1;
                 EXIT;
            END_IF;
            #i := #i + 1;
       END_WHILE;
       // Set the length of #MyString
       #MyWordsinString[0] := (#MyWordsinString[0] & 16#FF00) OR #i;
       #"P_Ctrld_Dev_Name" := #MyString;    //EPICSName: P_Controled_Dev_Name

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 22];
       #"P_OpMode_Index" := #MyInt;    //EPICSName: P_OpMode_Index

       #i := 0;
       WHILE TRUE DO
            IF #i = 20 THEN
                 #i := 39;
                 EXIT;
            END_IF;
            #MyWordsinString[#i + 1] := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 23 + #i];
            //Check if there is a terminating zero and store the string length in bytes
            IF (#MyWordsinString[#i + 1] & 16#FF00) = 0 THEN
                 #i := #i * 2;
                 EXIT;
            ELSIF (#MyWordsinString[#i + 1] & 16#00FF) = 0 THEN
                 #i := #i * 2 + 1;
                 EXIT;
            END_IF;
            #i := #i + 1;
       END_WHILE;
       // Set the length of #MyString
       #MyWordsinString[0] := (#MyWordsinString[0] & 16#FF00) OR #i;
       #"P_OpMode_Name" := #MyString;    //EPICSName: P_OpMode_Name

       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 43];
       #"P_SS_ON" := #MyBoolsinWord[8];    //EPICSName: P_SS_ON

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 44];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 45];
       #"P_SS_Setpoint" := #MyReal;    //EPICSName: P_SS_Setpoint

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 46];
       #"P_Meas_Dev_Index" := #MyInt;    //EPICSName: P_Meas_Dev_Index

       #i := 0;
       WHILE TRUE DO
            IF #i = 20 THEN
                 #i := 39;
                 EXIT;
            END_IF;
            #MyWordsinString[#i + 1] := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 47 + #i];
            //Check if there is a terminating zero and store the string length in bytes
            IF (#MyWordsinString[#i + 1] & 16#FF00) = 0 THEN
                 #i := #i * 2;
                 EXIT;
            ELSIF (#MyWordsinString[#i + 1] & 16#00FF) = 0 THEN
                 #i := #i * 2 + 1;
                 EXIT;
            END_IF;
            #i := #i + 1;
       END_WHILE;
       // Set the length of #MyString
       #MyWordsinString[0] := (#MyWordsinString[0] & 16#FF00) OR #i;
       #"P_Meas_Dev_Name" := #MyString;    //EPICSName: P_Measuring_Dev_Name

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 67];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 68];
       #"P_INT_Setpoint" := #MyReal;    //EPICSName: P_INT_Setpoint

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 69];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 70];
       #"P_LowLimit" := #MyReal;    //EPICSName: P_LowLimit

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 71];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 72];
       #"P_HighLimit" := #MyReal;    //EPICSName: P_HighLimit
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_C3S_DIAG"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "PS_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PS_Connected
      "CPU_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CPU_Connected
      "KF2_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF2_Connected
      "KF3_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF3_Connected
      "KF4_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF4_Connected
      "KF5_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF5_Connected
      "KF6_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF6_Connected
      "KF7_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF7_Connected
      "KF8_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF8_Connected
      "KF9_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF9_Connected
      "KF10_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF10_Connected
      "KF11_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF11_Connected
      "KF12_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF12_Connected
      "KF13_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF13_Connected
      "KF14_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF14_Connected
      "KF15_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF15_Connected
      "RIO1_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_Connected
      "RIO1_KF2_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF2_Connected
      "RIO1_KF3_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF3_Connected
      "RIO1_KF4_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF4_Connected
      "RIO1_KF5_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF5_Connected
      "RIO1_KF6_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF6_Connected
      "RIO1_KF7_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF7_Connected
      "RIO1_KF8_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF8_Connected
      "RIO1_KF9_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF9_Connected
      "RIO1_KF10_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF10_Connected
      "RIO1_KF11_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF11_Connected
      "RIO1_KF12_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF12_Connected
      "RIO1_KF13_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF13_Connected
      "RIO1_KF14_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF14_Connected
      "RIO1_KF15_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF15_Connected
      "LKSR01_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR01_Connected
      "LKSR02_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR02_Connected
      "LKSR03_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR03_Connected
      "LKSR04_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR04_Connected
      "LKSR05_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR05_Connected
      "LKSR06_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR06_Connected
      "LKSR07_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR07_Connected
      "LKSR08_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR08_Connected
      "LKSR09_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR09_Connected
      "LKSR10_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR10_Connected
      "CV01_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV01_Connected
      "CV02_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV02_Connected
      "CV03_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV03_Connected
      "CV04_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV04_Connected
      "CV05_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV05_Connected
      "CV06_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV06_Connected
      "CV11_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV11_Connected
      "CV12_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV12_Connected
      "CV21_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV21_Connected
      "CV22_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV22_Connected
      "CV32_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV32_Connected
      "CV42_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV42_Connected
      "CV60_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV60_Connected
      "CV61_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV61_Connected
      "CV62_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV62_Connected
      "CV63_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV63_Connected
      "CV71_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV71_Connected
      "CV80_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV80_Connected
      "CV81_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV81_Connected
      "CV91_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV91_Connected
      "CV92_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV92_Connected
      "CV93_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV93_Connected
      "CV94_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV94_Connected
      "PS_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PS_Status
      "CPU_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CPU_Status
      "KF2_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF2_Status
      "KF3_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF3_Status
      "KF4_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF4_Status
      "KF5_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF5_Status
      "KF6_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF6_Status
      "KF7_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF7_Status
      "KF8_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF8_Status
      "KF9_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF9_Status
      "KF10_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF10_Status
      "KF11_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF11_Status
      "KF12_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF12_Status
      "KF13_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF13_Status
      "KF14_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF14_Status
      "KF15_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: KF15_Status
      "RIO1_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_Status
      "RIO1_KF2_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF2_Status
      "RIO1_KF3_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF3_Status
      "RIO1_KF4_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF4_Status
      "RIO1_KF5_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF5_Status
      "RIO1_KF6_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF6_Status
      "RIO1_KF7_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF7_Status
      "RIO1_KF8_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF8_Status
      "RIO1_KF9_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF9_Status
      "RIO1_KF10_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF10_Status
      "RIO1_KF11_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF11_Status
      "RIO1_KF12_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF12_Status
      "RIO1_KF13_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF13_Status
      "RIO1_KF14_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF14_Status
      "RIO1_KF15_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO1_KF15_Status
      "LKSR01_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR01_Status
      "LKSR02_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR02_Status
      "LKSR03_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR03_Status
      "LKSR04_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR04_Status
      "LKSR05_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR05_Status
      "LKSR06_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR06_Status
      "LKSR07_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR07_Status
      "LKSR08_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR08_Status
      "LKSR09_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR09_Status
      "LKSR10_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LKSR10_Status
      "CV01_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV01_Status
      "CV02_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV02_Status
      "CV03_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV03_Status
      "CV04_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV04_Status
      "CV05_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV05_Status
      "CV06_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV06_Status
      "CV11_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV11_Status
      "CV12_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV12_Status
      "CV21_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV21_Status
      "CV22_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV22_Status
      "CV32_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV32_Status
      "CV42_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV42_Status
      "CV60_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV60_Status
      "CV61_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV61_Status
      "CV62_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV62_Status
      "CV63_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV63_Status
      "CV71_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV71_Status
      "CV80_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV80_Status
      "CV81_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV81_Status
      "CV91_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV91_Status
      "CV92_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV92_Status
      "CV93_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV93_Status
      "CV94_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CV94_Status
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: C3S_DIAG
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //#############################################################################
       //Type:     Cryo Systems
       //Project:  C3S
       //DevType:  C3S-:CRYO: DIAG - Diganostics
       //Author:	Madi Zoltan
       //Date:		05-10-2019
       //Version:  v3.0
       //###########################
       //STATUS BLOCK
       //###########################
       //Local modules connection state

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"PS_Connected";    //EPICSName: PS_Connected
       #MyBoolsinWord[9] := #"CPU_Connected";    //EPICSName: CPU_Connected
       #MyBoolsinWord[10] := #"KF2_Connected";    //EPICSName: KF2_Connected
       #MyBoolsinWord[11] := #"KF3_Connected";    //EPICSName: KF3_Connected
       #MyBoolsinWord[12] := #"KF4_Connected";    //EPICSName: KF4_Connected
       #MyBoolsinWord[13] := #"KF5_Connected";    //EPICSName: KF5_Connected
       #MyBoolsinWord[14] := #"KF6_Connected";    //EPICSName: KF6_Connected
       #MyBoolsinWord[15] := #"KF7_Connected";    //EPICSName: KF7_Connected
       #MyBoolsinWord[0] := #"KF8_Connected";    //EPICSName: KF8_Connected
       #MyBoolsinWord[1] := #"KF9_Connected";    //EPICSName: KF9_Connected
       #MyBoolsinWord[2] := #"KF10_Connected";    //EPICSName: KF10_Connected
       #MyBoolsinWord[3] := #"KF11_Connected";    //EPICSName: KF11_Connected
       #MyBoolsinWord[4] := #"KF12_Connected";    //EPICSName: KF12_Connected
       #MyBoolsinWord[5] := #"KF13_Connected";    //EPICSName: KF13_Connected
       #MyBoolsinWord[6] := #"KF14_Connected";    //EPICSName: KF14_Connected
       #MyBoolsinWord[7] := #"KF15_Connected";    //EPICSName: KF15_Connected
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"RIO1_Connected";    //EPICSName: RIO1_Connected
       #MyBoolsinWord[9] := #"RIO1_KF2_Connected";    //EPICSName: RIO1_KF2_Connected
       #MyBoolsinWord[10] := #"RIO1_KF3_Connected";    //EPICSName: RIO1_KF3_Connected
       #MyBoolsinWord[11] := #"RIO1_KF4_Connected";    //EPICSName: RIO1_KF4_Connected
       #MyBoolsinWord[12] := #"RIO1_KF5_Connected";    //EPICSName: RIO1_KF5_Connected
       #MyBoolsinWord[13] := #"RIO1_KF6_Connected";    //EPICSName: RIO1_KF6_Connected
       #MyBoolsinWord[14] := #"RIO1_KF7_Connected";    //EPICSName: RIO1_KF7_Connected
       #MyBoolsinWord[15] := #"RIO1_KF8_Connected";    //EPICSName: RIO1_KF8_Connected
       #MyBoolsinWord[0] := #"RIO1_KF9_Connected";    //EPICSName: RIO1_KF9_Connected
       #MyBoolsinWord[1] := #"RIO1_KF10_Connected";    //EPICSName: RIO1_KF10_Connected
       #MyBoolsinWord[2] := #"RIO1_KF11_Connected";    //EPICSName: RIO1_KF11_Connected
       #MyBoolsinWord[3] := #"RIO1_KF12_Connected";    //EPICSName: RIO1_KF12_Connected
       #MyBoolsinWord[4] := #"RIO1_KF13_Connected";    //EPICSName: RIO1_KF13_Connected
       #MyBoolsinWord[5] := #"RIO1_KF14_Connected";    //EPICSName: RIO1_KF14_Connected
       #MyBoolsinWord[6] := #"RIO1_KF15_Connected";    //EPICSName: RIO1_KF15_Connected
       #MyBoolsinWord[7] := #"LKSR01_Connected";    //EPICSName: LKSR01_Connected
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LKSR02_Connected";    //EPICSName: LKSR02_Connected
       #MyBoolsinWord[9] := #"LKSR03_Connected";    //EPICSName: LKSR03_Connected
       #MyBoolsinWord[10] := #"LKSR04_Connected";    //EPICSName: LKSR04_Connected
       #MyBoolsinWord[11] := #"LKSR05_Connected";    //EPICSName: LKSR05_Connected
       #MyBoolsinWord[12] := #"LKSR06_Connected";    //EPICSName: LKSR06_Connected
       #MyBoolsinWord[13] := #"LKSR07_Connected";    //EPICSName: LKSR07_Connected
       #MyBoolsinWord[14] := #"LKSR08_Connected";    //EPICSName: LKSR08_Connected
       #MyBoolsinWord[15] := #"LKSR09_Connected";    //EPICSName: LKSR09_Connected
       #MyBoolsinWord[0] := #"LKSR10_Connected";    //EPICSName: LKSR10_Connected
       #MyBoolsinWord[1] := #"CV01_Connected";    //EPICSName: CV01_Connected
       #MyBoolsinWord[2] := #"CV02_Connected";    //EPICSName: CV02_Connected
       #MyBoolsinWord[3] := #"CV03_Connected";    //EPICSName: CV03_Connected
       #MyBoolsinWord[4] := #"CV04_Connected";    //EPICSName: CV04_Connected
       #MyBoolsinWord[5] := #"CV05_Connected";    //EPICSName: CV05_Connected
       #MyBoolsinWord[6] := #"CV06_Connected";    //EPICSName: CV06_Connected
       #MyBoolsinWord[7] := #"CV11_Connected";    //EPICSName: CV11_Connected
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"CV12_Connected";    //EPICSName: CV12_Connected
       #MyBoolsinWord[9] := #"CV21_Connected";    //EPICSName: CV21_Connected
       #MyBoolsinWord[10] := #"CV22_Connected";    //EPICSName: CV22_Connected
       #MyBoolsinWord[11] := #"CV32_Connected";    //EPICSName: CV32_Connected
       #MyBoolsinWord[12] := #"CV42_Connected";    //EPICSName: CV42_Connected
       #MyBoolsinWord[13] := #"CV60_Connected";    //EPICSName: CV60_Connected
       #MyBoolsinWord[14] := #"CV61_Connected";    //EPICSName: CV61_Connected
       #MyBoolsinWord[15] := #"CV62_Connected";    //EPICSName: CV62_Connected
       #MyBoolsinWord[0] := #"CV63_Connected";    //EPICSName: CV63_Connected
       #MyBoolsinWord[1] := #"CV71_Connected";    //EPICSName: CV71_Connected
       #MyBoolsinWord[2] := #"CV80_Connected";    //EPICSName: CV80_Connected
       #MyBoolsinWord[3] := #"CV81_Connected";    //EPICSName: CV81_Connected
       #MyBoolsinWord[4] := #"CV91_Connected";    //EPICSName: CV91_Connected
       #MyBoolsinWord[5] := #"CV92_Connected";    //EPICSName: CV92_Connected
       #MyBoolsinWord[6] := #"CV93_Connected";    //EPICSName: CV93_Connected
       #MyBoolsinWord[7] := #"CV94_Connected";    //EPICSName: CV94_Connected
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"PS_Status";    //EPICSName: PS_Status
       #MyBoolsinWord[9] := #"CPU_Status";    //EPICSName: CPU_Status
       #MyBoolsinWord[10] := #"KF2_Status";    //EPICSName: KF2_Status
       #MyBoolsinWord[11] := #"KF3_Status";    //EPICSName: KF3_Status
       #MyBoolsinWord[12] := #"KF4_Status";    //EPICSName: KF4_Status
       #MyBoolsinWord[13] := #"KF5_Status";    //EPICSName: KF5_Status
       #MyBoolsinWord[14] := #"KF6_Status";    //EPICSName: KF6_Status
       #MyBoolsinWord[15] := #"KF7_Status";    //EPICSName: KF7_Status
       #MyBoolsinWord[0] := #"KF8_Status";    //EPICSName: KF8_Status
       #MyBoolsinWord[1] := #"KF9_Status";    //EPICSName: KF9_Status
       #MyBoolsinWord[2] := #"KF10_Status";    //EPICSName: KF10_Status
       #MyBoolsinWord[3] := #"KF11_Status";    //EPICSName: KF11_Status
       #MyBoolsinWord[4] := #"KF12_Status";    //EPICSName: KF12_Status
       #MyBoolsinWord[5] := #"KF13_Status";    //EPICSName: KF13_Status
       #MyBoolsinWord[6] := #"KF14_Status";    //EPICSName: KF14_Status
       #MyBoolsinWord[7] := #"KF15_Status";    //EPICSName: KF15_Status
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"RIO1_Status";    //EPICSName: RIO1_Status
       #MyBoolsinWord[9] := #"RIO1_KF2_Status";    //EPICSName: RIO1_KF2_Status
       #MyBoolsinWord[10] := #"RIO1_KF3_Status";    //EPICSName: RIO1_KF3_Status
       #MyBoolsinWord[11] := #"RIO1_KF4_Status";    //EPICSName: RIO1_KF4_Status
       #MyBoolsinWord[12] := #"RIO1_KF5_Status";    //EPICSName: RIO1_KF5_Status
       #MyBoolsinWord[13] := #"RIO1_KF6_Status";    //EPICSName: RIO1_KF6_Status
       #MyBoolsinWord[14] := #"RIO1_KF7_Status";    //EPICSName: RIO1_KF7_Status
       #MyBoolsinWord[15] := #"RIO1_KF8_Status";    //EPICSName: RIO1_KF8_Status
       #MyBoolsinWord[0] := #"RIO1_KF9_Status";    //EPICSName: RIO1_KF9_Status
       #MyBoolsinWord[1] := #"RIO1_KF10_Status";    //EPICSName: RIO1_KF10_Status
       #MyBoolsinWord[2] := #"RIO1_KF11_Status";    //EPICSName: RIO1_KF11_Status
       #MyBoolsinWord[3] := #"RIO1_KF12_Status";    //EPICSName: RIO1_KF12_Status
       #MyBoolsinWord[4] := #"RIO1_KF13_Status";    //EPICSName: RIO1_KF13_Status
       #MyBoolsinWord[5] := #"RIO1_KF14_Status";    //EPICSName: RIO1_KF14_Status
       #MyBoolsinWord[6] := #"RIO1_KF15_Status";    //EPICSName: RIO1_KF15_Status
       #MyBoolsinWord[7] := #"LKSR01_Status";    //EPICSName: LKSR01_Status
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LKSR02_Status";    //EPICSName: LKSR02_Status
       #MyBoolsinWord[9] := #"LKSR03_Status";    //EPICSName: LKSR03_Status
       #MyBoolsinWord[10] := #"LKSR04_Status";    //EPICSName: LKSR04_Status
       #MyBoolsinWord[11] := #"LKSR05_Status";    //EPICSName: LKSR05_Status
       #MyBoolsinWord[12] := #"LKSR06_Status";    //EPICSName: LKSR06_Status
       #MyBoolsinWord[13] := #"LKSR07_Status";    //EPICSName: LKSR07_Status
       #MyBoolsinWord[14] := #"LKSR08_Status";    //EPICSName: LKSR08_Status
       #MyBoolsinWord[15] := #"LKSR09_Status";    //EPICSName: LKSR09_Status
       #MyBoolsinWord[0] := #"LKSR10_Status";    //EPICSName: LKSR10_Status
       #MyBoolsinWord[1] := #"CV01_Status";    //EPICSName: CV01_Status
       #MyBoolsinWord[2] := #"CV02_Status";    //EPICSName: CV02_Status
       #MyBoolsinWord[3] := #"CV03_Status";    //EPICSName: CV03_Status
       #MyBoolsinWord[4] := #"CV04_Status";    //EPICSName: CV04_Status
       #MyBoolsinWord[5] := #"CV05_Status";    //EPICSName: CV05_Status
       #MyBoolsinWord[6] := #"CV06_Status";    //EPICSName: CV06_Status
       #MyBoolsinWord[7] := #"CV11_Status";    //EPICSName: CV11_Status
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"CV12_Status";    //EPICSName: CV12_Status
       #MyBoolsinWord[9] := #"CV21_Status";    //EPICSName: CV21_Status
       #MyBoolsinWord[10] := #"CV22_Status";    //EPICSName: CV22_Status
       #MyBoolsinWord[11] := #"CV32_Status";    //EPICSName: CV32_Status
       #MyBoolsinWord[12] := #"CV42_Status";    //EPICSName: CV42_Status
       #MyBoolsinWord[13] := #"CV60_Status";    //EPICSName: CV60_Status
       #MyBoolsinWord[14] := #"CV61_Status";    //EPICSName: CV61_Status
       #MyBoolsinWord[15] := #"CV62_Status";    //EPICSName: CV62_Status
       #MyBoolsinWord[0] := #"CV63_Status";    //EPICSName: CV63_Status
       #MyBoolsinWord[1] := #"CV71_Status";    //EPICSName: CV71_Status
       #MyBoolsinWord[2] := #"CV80_Status";    //EPICSName: CV80_Status
       #MyBoolsinWord[3] := #"CV81_Status";    //EPICSName: CV81_Status
       #MyBoolsinWord[4] := #"CV91_Status";    //EPICSName: CV91_Status
       #MyBoolsinWord[5] := #"CV92_Status";    //EPICSName: CV92_Status
       #MyBoolsinWord[6] := #"CV93_Status";    //EPICSName: CV93_Status
       #MyBoolsinWord[7] := #"CV94_Status";    //EPICSName: CV94_Status
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_AckAlarm" := #MyBoolsinWord[8];    //EPICSName: Cmd_AckAlarm
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_C3S_INTLCK"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "BeamVacuumOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: BeamVacuumOK
      "InsulationVacuumOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: InsulationVacuumOK
      "PressureHeGuardOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PressureHeGuardOK
      "RFON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RFON
      "WaterOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WaterOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "cmd_RFEnable" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: cmd_RFEnable
      "cmd_RFDisable" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: cmd_RFDisable
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: C3S_INTLCK
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //#############################################################################
       //Type:     Cryo Systems
       //Project:  C3S
       //DevType:  C3S-:CRYO: INTLCK - Interlocks
       //Author:	Fenyvesi Gabor
       //Date:		18-11-2019
       //Version:  v1.0
       //###########################
       //STATUS BLOCK
       //###########################
       //Vacuum

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"BeamVacuumOK";    //EPICSName: BeamVacuumOK
       #MyBoolsinWord[9] := #"InsulationVacuumOK";    //EPICSName: InsulationVacuumOK
       #MyBoolsinWord[10] := #"PressureHeGuardOK";    //EPICSName: PressureHeGuardOK
       #MyBoolsinWord[11] := #"RFON";    //EPICSName: RFON
       #MyBoolsinWord[12] := #"WaterOK";    //EPICSName: WaterOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"cmd_RFEnable" := #MyBoolsinWord[8];    //EPICSName: cmd_RFEnable
       #"cmd_RFDisable" := #MyBoolsinWord[9];    //EPICSName: cmd_RFDisable
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_C3S_MODE_SEL"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OM_Undefined" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_Undefined
      "OM_Stopped" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_Stopped
      "OM_Purging" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_Purging
      "OM_Ready" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_Ready
      "OM_CoolDownTo4K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_CoolDownTo4K
      "OM_StandBy4K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_StandBy4K
      "OM_CoolDownTo2K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_CoolDownTo2K
      "OM_StandBy2K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_StandBy2K
      "OM_Nominal2K_RF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_Nominal2K_RF
      "OM_WarmUpTo4K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_WarmUpTo4K
      "OM_WarmUpTo300K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_WarmUpTo300K
      "OM_WarmUpTo80K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_WarmUpTo80K
      "OM_StandBy80K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_StandBy80K
      "OM_CoolDown80KTo4K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_CoolDown80KTo4K
      "OM_WarmUp80KTo300K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_WarmUp80KTo300K
      "OM_CMWarmUpTo300K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_CMWarmUpTo300K
      "OM_CMCoolDownTo4K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_CMCoolDownTo4K
      "OM_Starting" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OM_Starting
      "OM_State" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: OM_State
      "OM_Msg" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: OM_Msg
      "TimeInCurrentMode" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : TIME;   //EPICS Status variable: TimeInCurrentMode
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_Stop_system" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Stop_system
      "Cmd_Start_system" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Start_system
      "Cmd_Stand_by_4K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Stand_by_4K
      "Cmd_Stand_by_2K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Stand_by_2K
      "Cmd_Nominal_2K_RF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Nominal_2K_RF
      "Cmd_Stand_by_300K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Stand_by_300K
      "Cmd_Stand_by_80K" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Stand_by_80K
      "Cmd_Reset" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Reset
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: C3S_MODE_SEL
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //#############################################################################################
       //MODE SELECTION INTERFACE
       //#############################################################################################
       //Author:   ZMa
       //Date:	    14-01-2020
       //Version:  v1.1
       //Note:
       //#############################################################################################
       //Author:   EAsensi
       //Date:	    26-01-2021
       //Version:  v1.2
       //Note: Shortened names for EPICS
       //#############################################################################################
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OM_Undefined";    //EPICSName: OM_Undefined
       #MyBoolsinWord[9] := #"OM_Stopped";    //EPICSName: OM_Stopped
       #MyBoolsinWord[10] := #"OM_Purging";    //EPICSName: OM_Purging
       #MyBoolsinWord[11] := #"OM_Ready";    //EPICSName: OM_Ready
       #MyBoolsinWord[12] := #"OM_CoolDownTo4K";    //EPICSName: OM_CoolDownTo4K
       #MyBoolsinWord[13] := #"OM_StandBy4K";    //EPICSName: OM_StandBy4K
       #MyBoolsinWord[14] := #"OM_CoolDownTo2K";    //EPICSName: OM_CoolDownTo2K
       #MyBoolsinWord[15] := #"OM_StandBy2K";    //EPICSName: OM_StandBy2K
       #MyBoolsinWord[0] := #"OM_Nominal2K_RF";    //EPICSName: OM_Nominal2K_RF
       #MyBoolsinWord[1] := #"OM_WarmUpTo4K";    //EPICSName: OM_WarmUpTo4K
       #MyBoolsinWord[2] := #"OM_WarmUpTo300K";    //EPICSName: OM_WarmUpTo300K
       #MyBoolsinWord[3] := #"OM_WarmUpTo80K";    //EPICSName: OM_WarmUpTo80K
       #MyBoolsinWord[4] := #"OM_StandBy80K";    //EPICSName: OM_StandBy80K
       #MyBoolsinWord[5] := #"OM_CoolDown80KTo4K";    //EPICSName: OM_CoolDown80KTo4K
       #MyBoolsinWord[6] := #"OM_WarmUp80KTo300K";    //EPICSName: OM_WarmUp80KTo300K
       #MyBoolsinWord[7] := #"OM_CMWarmUpTo300K";    //EPICSName: OM_CMWarmUpTo300K
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OM_CMCoolDownTo4K";    //EPICSName: OM_CMCoolDownTo4K
       #MyBoolsinWord[9] := #"OM_Starting";    //EPICSName: OM_Starting
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWord;

       #MyInt := #"OM_State";    //EPICSName: OM_State
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWordinInt;

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"OM_Msg";  //EPICSName: OM_Msg
       FOR #i:=0 TO 18 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3 + 19] := #MyWordsinString[20] & 16#FF00;

       #MyTime := #"TimeInCurrentMode";    //EPICSName: TimeInCurrentMode
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 23] := #MyWordsinTime[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 24] := #MyWordsinTime[1];

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_Stop_system" := #MyBoolsinWord[8];    //EPICSName: Cmd_Stop_system
       #"Cmd_Start_system" := #MyBoolsinWord[9];    //EPICSName: Cmd_Start_system
       #"Cmd_Stand_by_4K" := #MyBoolsinWord[10];    //EPICSName: Cmd_Stand_by_4K
       #"Cmd_Stand_by_2K" := #MyBoolsinWord[11];    //EPICSName: Cmd_Stand_by_2K
       #"Cmd_Nominal_2K_RF" := #MyBoolsinWord[12];    //EPICSName: Cmd_Nominal_2K_RF
       #"Cmd_Stand_by_300K" := #MyBoolsinWord[13];    //EPICSName: Cmd_Stand_by_300K
       #"Cmd_Stand_by_80K" := #MyBoolsinWord[14];    //EPICSName: Cmd_Stand_by_80K
       #"Cmd_Reset" := #MyBoolsinWord[15];    //EPICSName: Cmd_Reset
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_C3S_PID"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpMode_Auto" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Auto
      "OpMode_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Manual
      "OpMode_Forced" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Forced
      "PID_Color" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: PID_Color
      "LMN" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: LMN
      "LMN_P" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: LMN_P
      "LMN_I" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: LMN_I
      "LMN_D" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: LMN_D
      "PID_DIF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: PID_DIF
      "PV" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: PV
      "MAN_SP" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MAN_SP
      "PID_Cycle" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: PID_Cycle
      "ProcValueName" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: ProcValueName
      "ProcValueEGU" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: ProcValueEGU
      "Inhibit_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Manual
      "Inhibit_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Force
      "Inhibit_Lock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Lock
      "MoveInterlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: MoveInterlock
      "GroupInterlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupInterlock
      "EnableAutoBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableAutoBtn
      "EnableManualBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableManualBtn
      "EnableForcedBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForcedBtn
      "EnablePIDConf" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnablePIDConf
      "LatchAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LatchAlarm
      "GroupAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupAlarm
      "EnableBlkCtrl" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableBlkCtrl
      "EnableForceValBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForceValBtn
      "DevLocked" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DevLocked
      "Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: Faceplate_LockID
      "BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: BlockIcon_LockID
      "LMN_HLIM" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LMN_HLIM
      "LMN_LLIM" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LMN_LLIM
      "IO_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IO_Error
      "Input_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Input_Module_Error
      "Output_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Output_Module_Error
      "Discrepancy_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Discrepancy_Error
      "ContDeviceInMan" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ContDeviceInMan
      "FB_Gain" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Gain
      "FB_TI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: FB_TI
      "FB_TD" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: FB_TD
      "FB_DEADB" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_DEADB
      "FB_LMN_HLIM" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_LMN_HLIM
      "FB_LMN_LLIM" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_LMN_LLIM
      "FB_ForcePosition" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_ForcePosition
      "FB_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Setpoint
      "FB_Step" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Step
      "FB_Manipulated" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Manipulated
      "FB_P_ActionState" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: FB_P_ActionState
      "FB_I_ActionState" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: FB_I_ActionState
      "FB_D_ActionState" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: FB_D_ActionState
      "FB_SS_State" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: FB_SS_State
      "FB_SS_Value" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_SS_Value
      "MeasValue_Msg" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: Measured_Value_Msg
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_Auto" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Auto
      "Cmd_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Manual
      "Cmd_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Force
      "Cmd_EnablePID_Conf" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_EnablePID_Conf
      "Cmd_DisablePID_Conf" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DisablePID_Conf
      "Cmd_P_ON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_P_ON
      "Cmd_P_OFF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_P_OFF
      "Cmd_I_ON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_I_ON
      "Cmd_I_OFF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_I_OFF
      "Cmd_D_ON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_D_ON
      "Cmd_D_OFF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_D_OFF
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      "Cmd_ForceValInp" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceValInp
      "Cmd_ForceValOut" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceValOut
      "Cmd_ForceUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceUnlock
      "Cmd_DevLock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevLock
      "Cmd_DevUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevUnlock
      "P_Gain" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Gain
      "P_TI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_TI
      "P_TD" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_TD
      "P_DEADB" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_DEADB
      "P_LMN_HLIM" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_LMN_HLIM
      "P_LMN_LLIM" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_LMN_LLIM
      "P_ForcePosition" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_ForcePosition
      "P_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Setpoint
      "P_Manipulated" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Manipulated
      "P_Step" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Step
      "P_Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_Faceplate_LockID
      "P_BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_BlockIcon_LockID
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: C3S_PID
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //##################################### ICS HWI ###############################################
       //############################  ICS Instrument Library     ####################################
       //#  PLC Sample Code in VersionDog: ICS_LIBRARY_MASTER_PLC                                   ##
       //#  CCDB device types: ICS_xxxxx                                                            ##
       //#  EPICS HMI (Block Icons/Faceplates)@ GitLab. Projekt: Cryo / CryogenicsLibrary / CryoLib ##
       //#                                                                                          ##
       //#                                 PID - PID Control                                        ##
       //#                                                                                          ##
       //#                                                                                          ##
       //###########################           Version: 1.2           ################################
       //Author:	Zoltan Madi
       //Date:		13-12-2019
       //Version:  v1.2
       //Changes:  Added "MeasValue_Msg"
       //###########################           Version: 1.1           ################################
       //Author:	Johannes Kazantzidis
       //Date:		13-12-2019
       //Version:  v1.1
       //Changes:  Added alarm signal "Discrepancy_Error"
       //###########################           Version: 1.0           ################################
       //Author:	Miklos Boros
       //Date:		01-09-2019
       //Version:  v1.0
       //Changes:  First release and alarm signal "Discrepancy_Error"
       //#############################################################################################
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons
       //PID

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpMode_Auto";    //EPICSName: OpMode_Auto
       #MyBoolsinWord[9] := #"OpMode_Manual";    //EPICSName: OpMode_Manual
       #MyBoolsinWord[10] := #"OpMode_Forced";    //EPICSName: OpMode_Forced
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyInt := #"PID_Color";    //EPICSName: PID_Color
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordinInt;

       #MyReal := #"LMN";    //EPICSName: LMN
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWordsinReal[1];

       #MyReal := #"LMN_P";    //EPICSName: LMN_P
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWordsinReal[1];

       #MyReal := #"LMN_I";    //EPICSName: LMN_I
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWordsinReal[1];

       #MyReal := #"LMN_D";    //EPICSName: LMN_D
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 8] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 9] := #MyWordsinReal[1];

       #MyReal := #"PID_DIF";    //EPICSName: PID_DIF
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 10] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 11] := #MyWordsinReal[1];

       #MyReal := #"PV";    //EPICSName: PV
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 12] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 13] := #MyWordsinReal[1];

       #MyReal := #"MAN_SP";    //EPICSName: MAN_SP
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 14] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 15] := #MyWordsinReal[1];

       #MyInt := #"PID_Cycle";    //EPICSName: PID_Cycle
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 16] := #MyWordinInt;

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"ProcValueName";  //EPICSName: ProcValueName
       FOR #i:=0 TO 18 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 17 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 17 + 19] := #MyWordsinString[20] & 16#FF00;

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"ProcValueEGU";  //EPICSName: ProcValueEGU
       FOR #i:=0 TO 2 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 37 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 37 + 3] := 0;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Inhibit_Manual";    //EPICSName: Inhibit_Manual
       #MyBoolsinWord[9] := #"Inhibit_Force";    //EPICSName: Inhibit_Force
       #MyBoolsinWord[10] := #"Inhibit_Lock";    //EPICSName: Inhibit_Lock
       #MyBoolsinWord[11] := #"MoveInterlock";    //EPICSName: MoveInterlock
       #MyBoolsinWord[12] := #"GroupInterlock";    //EPICSName: GroupInterlock
       #MyBoolsinWord[13] := #"EnableAutoBtn";    //EPICSName: EnableAutoBtn
       #MyBoolsinWord[14] := #"EnableManualBtn";    //EPICSName: EnableManualBtn
       #MyBoolsinWord[15] := #"EnableForcedBtn";    //EPICSName: EnableForcedBtn
       #MyBoolsinWord[0] := #"EnablePIDConf";    //EPICSName: EnablePIDConf
       #MyBoolsinWord[1] := #"LatchAlarm";    //EPICSName: LatchAlarm
       #MyBoolsinWord[2] := #"GroupAlarm";    //EPICSName: GroupAlarm
       #MyBoolsinWord[3] := #"EnableBlkCtrl";    //EPICSName: EnableBlkCtrl
       #MyBoolsinWord[4] := #"EnableForceValBtn";    //EPICSName: EnableForceValBtn
       #MyBoolsinWord[5] := #"DevLocked";    //EPICSName: DevLocked
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 41] := #MyWord;

       #MyDInt := #"Faceplate_LockID";    //EPICSName: Faceplate_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 42] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 43] := #MyWordsinDint[1];

       #MyDInt := #"BlockIcon_LockID";    //EPICSName: BlockIcon_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 44] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 45] := #MyWordsinDint[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LMN_HLIM";    //EPICSName: LMN_HLIM
       #MyBoolsinWord[9] := #"LMN_LLIM";    //EPICSName: LMN_LLIM
       #MyBoolsinWord[10] := #"IO_Error";    //EPICSName: IO_Error
       #MyBoolsinWord[11] := #"Input_Module_Error";    //EPICSName: Input_Module_Error
       #MyBoolsinWord[12] := #"Output_Module_Error";    //EPICSName: Output_Module_Error
       #MyBoolsinWord[13] := #"Discrepancy_Error";    //EPICSName: Discrepancy_Error
       #MyBoolsinWord[14] := #"ContDeviceInMan";    //EPICSName: ContDeviceInMan
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 46] := #MyWord;

       #MyReal := #"FB_Gain";    //EPICSName: FB_Gain
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 47] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 48] := #MyWordsinReal[1];

       #MyDInt := #"FB_TI";    //EPICSName: FB_TI
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 49] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 50] := #MyWordsinDint[1];

       #MyDInt := #"FB_TD";    //EPICSName: FB_TD
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 51] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 52] := #MyWordsinDint[1];

       #MyReal := #"FB_DEADB";    //EPICSName: FB_DEADB
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 53] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 54] := #MyWordsinReal[1];

       #MyReal := #"FB_LMN_HLIM";    //EPICSName: FB_LMN_HLIM
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 55] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 56] := #MyWordsinReal[1];

       #MyReal := #"FB_LMN_LLIM";    //EPICSName: FB_LMN_LLIM
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 57] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 58] := #MyWordsinReal[1];

       #MyReal := #"FB_ForcePosition";    //EPICSName: FB_ForcePosition
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 59] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 60] := #MyWordsinReal[1];

       #MyReal := #"FB_Setpoint";    //EPICSName: FB_Setpoint
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 61] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 62] := #MyWordsinReal[1];

       #MyReal := #"FB_Step";    //EPICSName: FB_Step
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 63] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 64] := #MyWordsinReal[1];

       #MyReal := #"FB_Manipulated";    //EPICSName: FB_Manipulated
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 65] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 66] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"FB_P_ActionState";    //EPICSName: FB_P_ActionState
       #MyBoolsinWord[9] := #"FB_I_ActionState";    //EPICSName: FB_I_ActionState
       #MyBoolsinWord[10] := #"FB_D_ActionState";    //EPICSName: FB_D_ActionState
       #MyBoolsinWord[11] := #"FB_SS_State";    //EPICSName: FB_SS_State
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 67] := #MyWord;

       #MyReal := #"FB_SS_Value";    //EPICSName: FB_SS_Value
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 68] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 69] := #MyWordsinReal[1];

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"MeasValue_Msg";  //EPICSName: Measured_Value_Msg
       FOR #i:=0 TO 18 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 70 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 70 + 19] := #MyWordsinString[20] & 16#FF00;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_Auto" := #MyBoolsinWord[8];    //EPICSName: Cmd_Auto
       #"Cmd_Manual" := #MyBoolsinWord[9];    //EPICSName: Cmd_Manual
       #"Cmd_Force" := #MyBoolsinWord[10];    //EPICSName: Cmd_Force
       #"Cmd_EnablePID_Conf" := #MyBoolsinWord[11];    //EPICSName: Cmd_EnablePID_Conf
       #"Cmd_DisablePID_Conf" := #MyBoolsinWord[12];    //EPICSName: Cmd_DisablePID_Conf
       #"Cmd_P_ON" := #MyBoolsinWord[13];    //EPICSName: Cmd_P_ON
       #"Cmd_P_OFF" := #MyBoolsinWord[14];    //EPICSName: Cmd_P_OFF
       #"Cmd_I_ON" := #MyBoolsinWord[15];    //EPICSName: Cmd_I_ON
       #"Cmd_I_OFF" := #MyBoolsinWord[0];    //EPICSName: Cmd_I_OFF
       #"Cmd_D_ON" := #MyBoolsinWord[1];    //EPICSName: Cmd_D_ON
       #"Cmd_D_OFF" := #MyBoolsinWord[2];    //EPICSName: Cmd_D_OFF
       #"Cmd_AckAlarm" := #MyBoolsinWord[3];    //EPICSName: Cmd_AckAlarm
       #"Cmd_ForceValInp" := #MyBoolsinWord[4];    //EPICSName: Cmd_ForceValInp
       #"Cmd_ForceValOut" := #MyBoolsinWord[5];    //EPICSName: Cmd_ForceValOut
       #"Cmd_ForceUnlock" := #MyBoolsinWord[6];    //EPICSName: Cmd_ForceUnlock
       #"Cmd_DevLock" := #MyBoolsinWord[7];    //EPICSName: Cmd_DevLock

       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1] := 0;
       #"Cmd_DevUnlock" := #MyBoolsinWord[8];    //EPICSName: Cmd_DevUnlock

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #"P_Gain" := #MyReal;    //EPICSName: P_Gain

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 4];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 5];
       #"P_TI" := #MyDInt;    //EPICSName: P_TI

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 6];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 7];
       #"P_TD" := #MyDInt;    //EPICSName: P_TD

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 8];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 9];
       #"P_DEADB" := #MyReal;    //EPICSName: P_DEADB

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 10];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 11];
       #"P_LMN_HLIM" := #MyReal;    //EPICSName: P_LMN_HLIM

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 12];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 13];
       #"P_LMN_LLIM" := #MyReal;    //EPICSName: P_LMN_LLIM

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 14];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 15];
       #"P_ForcePosition" := #MyReal;    //EPICSName: P_ForcePosition

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 16];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 17];
       #"P_Setpoint" := #MyReal;    //EPICSName: P_Setpoint

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 18];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 19];
       #"P_Manipulated" := #MyReal;    //EPICSName: P_Manipulated

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 20];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 21];
       #"P_Step" := #MyReal;    //EPICSName: P_Step

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 22];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 23];
       #"P_Faceplate_LockID" := #MyDInt;    //EPICSName: P_Faceplate_LockID

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 24];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 25];
       #"P_BlockIcon_LockID" := #MyDInt;    //EPICSName: P_BlockIcon_LockID
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ICS_CV_PB_SIPART"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpMode_Auto" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Auto
      "OpMode_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Manual
      "OpMode_Forced" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Forced
      "ValveColor" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: ValveColor
      "ValvePosition" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ValvePosition
      "ValveSP" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ValveSP
      "ValveMV" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ValveMV
      "Opening" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Opening
      "Closing" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Closing
      "StatusRB" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BYTE;   //EPICS Status variable: StatusRB
      "DiscretePosition" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: DiscretePosition
      "DiscreteStatus" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BYTE;   //EPICS Status variable: DiscreteStatus
      "DiagnosticsCB01" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BYTE;   //EPICS Status variable: DiagnosticsCB01
      "DiagnosticsCB02" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BYTE;   //EPICS Status variable: DiagnosticsCB02
      "DiagnosticsCB03" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BYTE;   //EPICS Status variable: DiagnosticsCB03
      "Inhibit_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Manual
      "Inhibit_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Force
      "Inhibit_Lock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Lock
      "GroupInterlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupInterlock
      "InterlockMsg" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : STRING;   //EPICS Status variable: InterlockMsg
      "MoveInterlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: MoveInterlock
      "EnableAutoBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableAutoBtn
      "EnableManualBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableManualBtn
      "EnableForcedBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForcedBtn
      "EnableBlkCtrl" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableBlkCtrl
      "EnableForceValBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForceValBtn
      "DevLocked" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DevLocked
      "Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: Faceplate_LockID
      "BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: BlockIcon_LockID
      "LatchAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LatchAlarm
      "GroupAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupAlarm
      "Position_Discrep" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Position_Discrep
      "IO_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IO_Error
      "Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Module_Error
      "Input_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Input_Module_Error
      "Output_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Output_Module_Error
      "SPLimitActive" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: SPLimitActive
      "SSTriggered" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: SSTriggered
      "DiscrPerc" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: DiscrPerc
      "DiscrTime" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : TIME;   //EPICS Status variable: DiscrTime
      "MaxRampUPSpd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MaxRampUPSpd
      "MaxRampDNSpd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MaxRampDNSpd
      "ActRampSpeed" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ActRampSpeed
      "Ramping" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Ramping
      "RampSettingOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RampSettingOK
      "FB_RampUPTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: FB_RampUPTIME
      "FB_RampUPRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_RampUPRANGE
      "FB_RampDNTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: FB_RampDNTIME
      "FB_RampDNRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_RampDNRANGE
      "FB_ForcePosition" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_ForcePosition
      "FB_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Setpoint
      "FB_Manipulated" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Manipulated
      "FB_Step" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Step
      "FB_RampTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: FB_RampTIME
      "FB_RampRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_RampRANGE
      "Timer_enabled" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Timer_enabled
      "T_triggered" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: T_triggered
      "T_running" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: T_running
      "F_enabled" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_enabled
      "FiltedValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FiltedValue
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_Auto" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Auto
      "Cmd_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Manual
      "Cmd_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Force
      "Cmd_RampON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_RampON
      "Cmd_RampOFF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_RampOFF
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      "Cmd_ForceValInp" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceValInp
      "Cmd_ForceValOut" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceValOut
      "Cmd_ForceUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceUnlock
      "Cmd_DevLock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevLock
      "Cmd_DevUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevUnlock
      "P_ForcePosition" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_ForcePosition
      "P_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Setpoint
      "P_Manipulated" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Manipulated
      "P_Step" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Step
      "P_RampUPTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: P_RampUPTIME
      "P_RampUPRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_RampUPRANGE
      "P_RampDNTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: P_RampDNTIME
      "P_RampDNRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_RampDNRANGE
      "P_Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_Faceplate_LockID
      "P_BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_BlockIcon_LockID
      "T_period" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: T_period
      "F_interval" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: F_interval
      "F_buffer" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: F_buffer
      "F_Enable" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Parameter variable: F_Enable
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: ICS_CV_PB_SIPART
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //##################################### ICS HWI ###############################################
       //############################  ICS Instrument Library     ####################################
       //#  PLC Sample Code in VersionDog: ICS_LIBRARY_MASTER_PLC                                   ##
       //#  CCDB device types: ICS_CV_PB_SIPART                                                           ##
       //#  EPICS HMI (Block Icons/Faceplates)@ GitLab. Projekt: Cryo / CryogenicsLibrary / CryoLib ##
       //#                                                                                          ##
       //Siemens Sipart PS2 Valve Positioner
       //#                                                                                          ##
       //#
       //###########################           Version: 1.7           ################################
       //Author:	Emilio Asensi
       //Date:		06-09-2022
       //Version:  v1.7
       //Changes:
       //Added pvs for timer and filter
       //###########################           Version: 1.6           ################################
       //Author:	Emilio Asensi
       //Date:		03-05-2021
       //Version:  v1.6
       //Changes:
       //Added missing alarm signals                                                                                  ##
       //###########################           Version: 1.5           ################################
       //Author:	Peter Talas
       //Date:		16-03-2021
       //Version:  v1.5
       //Changes:
       //Archiving added
       //rpm changed to % on the ramping parameters
       //Interlock Message added
       //###########################           Version: 1.4           ################################
       //Author:	Miklos Boros
       //Date:		27-05-2019
       //Version:  v1.4
       //Changes:
       //Integration to CryoLibrary
       //Variable name unification
       //###########################           Version: 1.3           ################################
       //Author:	Emilio Asensi
       //Date:		24-01-2019
       //Version:  v1.3
       //Changes:
       //Accommodate changes on CMS_CV
       //1. Changed smoother ramping
       //Sipart module information
       //2. Removed Cascade operation
       //3. Modified CheckBack diagnostic bytes
       //###########################           Version: 1.2           ################################
       //Author:	Emilio Asensi
       //Date:		13-09-2018
       //Version:  v1.2
       //Changes:
       //Accommodate the changes on CMS_CV
       //1. Modified "For OPI visualisation" section: Added digital variable "FB_Keep_Setpoint".
       //2. Modified "Parameter Block" section: Added digital variable "P_Keep_Setpoint".
       //3. Modified Alarm Signal section to be compatible with new format.
       //###########################           Version: 1.0           ################################
       //Author:   Miklos Boros, Emilio Asensi
       //Date:	    17-05-2018
       //Version:  v1.0
       //Note:     Based on CMS_CV.def
       //#############################################################################################
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons
       //Setpoint and Manipulated value from HMI

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpMode_Auto";    //EPICSName: OpMode_Auto
       #MyBoolsinWord[9] := #"OpMode_Manual";    //EPICSName: OpMode_Manual
       #MyBoolsinWord[10] := #"OpMode_Forced";    //EPICSName: OpMode_Forced
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyInt := #"ValveColor";    //EPICSName: ValveColor
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordinInt;

       #MyReal := #"ValvePosition";    //EPICSName: ValvePosition
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWordsinReal[1];

       #MyReal := #"ValveSP";    //EPICSName: ValveSP
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWordsinReal[1];

       #MyReal := #"ValveMV";    //EPICSName: ValveMV
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Opening";    //EPICSName: Opening
       #MyBoolsinWord[9] := #"Closing";    //EPICSName: Closing
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 8] := #MyWord;

       #MyWord := W#0;
       #MyBytesinWord[0] := #"StatusRB";    //EPICSName: StatusRB
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 9] := #MyWord;

       #MyInt := #"DiscretePosition";    //EPICSName: DiscretePosition
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 10] := #MyWordinInt;

       #MyWord := W#0;
       #MyBytesinWord[0] := #"DiscreteStatus";    //EPICSName: DiscreteStatus
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 11] := #MyWord;

       #MyWord := W#0;
       #MyBytesinWord[0] := #"DiagnosticsCB01";    //EPICSName: DiagnosticsCB01
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 12] := #MyWord;

       #MyWord := W#0;
       #MyBytesinWord[0] := #"DiagnosticsCB02";    //EPICSName: DiagnosticsCB02
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 13] := #MyWord;

       #MyWord := W#0;
       #MyBytesinWord[0] := #"DiagnosticsCB03";    //EPICSName: DiagnosticsCB03
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 14] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Inhibit_Manual";    //EPICSName: Inhibit_Manual
       #MyBoolsinWord[9] := #"Inhibit_Force";    //EPICSName: Inhibit_Force
       #MyBoolsinWord[10] := #"Inhibit_Lock";    //EPICSName: Inhibit_Lock
       #MyBoolsinWord[11] := #"GroupInterlock";    //EPICSName: GroupInterlock
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 15] := #MyWord;

       // Clear the buffer of any residual data, but skip the first word as that is the actual and maximum length
       FOR #i:=1 TO 20 DO
            #MyWordsinString[#i] := 0;
       END_FOR;
       #MyString := #"InterlockMsg";  //EPICSName: InterlockMsg
       FOR #i:=0 TO 18 DO
            "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 16 + #i] := #MyWordsinString[#i + 1];
       END_FOR;
       // Terminate C-string
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 16 + 19] := #MyWordsinString[20] & 16#FF00;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"MoveInterlock";    //EPICSName: MoveInterlock
       #MyBoolsinWord[9] := #"EnableAutoBtn";    //EPICSName: EnableAutoBtn
       #MyBoolsinWord[10] := #"EnableManualBtn";    //EPICSName: EnableManualBtn
       #MyBoolsinWord[11] := #"EnableForcedBtn";    //EPICSName: EnableForcedBtn
       #MyBoolsinWord[12] := #"EnableBlkCtrl";    //EPICSName: EnableBlkCtrl
       #MyBoolsinWord[13] := #"EnableForceValBtn";    //EPICSName: EnableForceValBtn
       #MyBoolsinWord[14] := #"DevLocked";    //EPICSName: DevLocked
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 36] := #MyWord;

       #MyDInt := #"Faceplate_LockID";    //EPICSName: Faceplate_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 37] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 38] := #MyWordsinDint[1];

       #MyDInt := #"BlockIcon_LockID";    //EPICSName: BlockIcon_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 39] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 40] := #MyWordsinDint[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LatchAlarm";    //EPICSName: LatchAlarm
       #MyBoolsinWord[9] := #"GroupAlarm";    //EPICSName: GroupAlarm
       #MyBoolsinWord[10] := #"Position_Discrep";    //EPICSName: Position_Discrep
       #MyBoolsinWord[11] := #"IO_Error";    //EPICSName: IO_Error
       #MyBoolsinWord[12] := #"Module_Error";    //EPICSName: Module_Error
       #MyBoolsinWord[13] := #"Input_Module_Error";    //EPICSName: Input_Module_Error
       #MyBoolsinWord[14] := #"Output_Module_Error";    //EPICSName: Output_Module_Error
       #MyBoolsinWord[15] := #"SPLimitActive";    //EPICSName: SPLimitActive
       #MyBoolsinWord[0] := #"SSTriggered";    //EPICSName: SSTriggered
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 41] := #MyWord;

       #MyReal := #"DiscrPerc";    //EPICSName: DiscrPerc
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 42] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 43] := #MyWordsinReal[1];

       #MyTime := #"DiscrTime";    //EPICSName: DiscrTime
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 44] := #MyWordsinTime[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 45] := #MyWordsinTime[1];

       #MyReal := #"MaxRampUPSpd";    //EPICSName: MaxRampUPSpd
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 46] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 47] := #MyWordsinReal[1];

       #MyReal := #"MaxRampDNSpd";    //EPICSName: MaxRampDNSpd
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 48] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 49] := #MyWordsinReal[1];

       #MyReal := #"ActRampSpeed";    //EPICSName: ActRampSpeed
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 50] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 51] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Ramping";    //EPICSName: Ramping
       #MyBoolsinWord[9] := #"RampSettingOK";    //EPICSName: RampSettingOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 52] := #MyWord;

       #MyInt := #"FB_RampUPTIME";    //EPICSName: FB_RampUPTIME
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 53] := #MyWordinInt;

       #MyReal := #"FB_RampUPRANGE";    //EPICSName: FB_RampUPRANGE
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 54] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 55] := #MyWordsinReal[1];

       #MyInt := #"FB_RampDNTIME";    //EPICSName: FB_RampDNTIME
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 56] := #MyWordinInt;

       #MyReal := #"FB_RampDNRANGE";    //EPICSName: FB_RampDNRANGE
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 57] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 58] := #MyWordsinReal[1];

       #MyReal := #"FB_ForcePosition";    //EPICSName: FB_ForcePosition
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 59] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 60] := #MyWordsinReal[1];

       #MyReal := #"FB_Setpoint";    //EPICSName: FB_Setpoint
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 61] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 62] := #MyWordsinReal[1];

       #MyReal := #"FB_Manipulated";    //EPICSName: FB_Manipulated
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 63] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 64] := #MyWordsinReal[1];

       #MyReal := #"FB_Step";    //EPICSName: FB_Step
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 65] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 66] := #MyWordsinReal[1];

       #MyInt := #"FB_RampTIME";    //EPICSName: FB_RampTIME
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 67] := #MyWordinInt;

       #MyReal := #"FB_RampRANGE";    //EPICSName: FB_RampRANGE
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 68] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 69] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Timer_enabled";    //EPICSName: Timer_enabled
       #MyBoolsinWord[9] := #"T_triggered";    //EPICSName: T_triggered
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 70] := #MyWord;

       #MyInt := #"T_running";    //EPICSName: T_running
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 71] := #MyWordinInt;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"F_enabled";    //EPICSName: F_enabled
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 72] := #MyWord;

       #MyReal := #"FiltedValue";    //EPICSName: FiltedValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 73] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 74] := #MyWordsinReal[1];

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_Auto" := #MyBoolsinWord[8];    //EPICSName: Cmd_Auto
       #"Cmd_Manual" := #MyBoolsinWord[9];    //EPICSName: Cmd_Manual
       #"Cmd_Force" := #MyBoolsinWord[10];    //EPICSName: Cmd_Force
       #"Cmd_RampON" := #MyBoolsinWord[11];    //EPICSName: Cmd_RampON
       #"Cmd_RampOFF" := #MyBoolsinWord[12];    //EPICSName: Cmd_RampOFF
       #"Cmd_AckAlarm" := #MyBoolsinWord[13];    //EPICSName: Cmd_AckAlarm
       #"Cmd_ForceValInp" := #MyBoolsinWord[14];    //EPICSName: Cmd_ForceValInp
       #"Cmd_ForceValOut" := #MyBoolsinWord[15];    //EPICSName: Cmd_ForceValOut
       #"Cmd_ForceUnlock" := #MyBoolsinWord[0];    //EPICSName: Cmd_ForceUnlock
       #"Cmd_DevLock" := #MyBoolsinWord[1];    //EPICSName: Cmd_DevLock
       #"Cmd_DevUnlock" := #MyBoolsinWord[2];    //EPICSName: Cmd_DevUnlock

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"P_ForcePosition" := #MyReal;    //EPICSName: P_ForcePosition

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 4];
       #"P_Setpoint" := #MyReal;    //EPICSName: P_Setpoint

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 5];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 6];
       #"P_Manipulated" := #MyReal;    //EPICSName: P_Manipulated

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 7];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 8];
       #"P_Step" := #MyReal;    //EPICSName: P_Step

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 9];
       #"P_RampUPTIME" := #MyInt;    //EPICSName: P_RampUPTIME

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 10];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 11];
       #"P_RampUPRANGE" := #MyReal;    //EPICSName: P_RampUPRANGE

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 12];
       #"P_RampDNTIME" := #MyInt;    //EPICSName: P_RampDNTIME

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 13];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 14];
       #"P_RampDNRANGE" := #MyReal;    //EPICSName: P_RampDNRANGE

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 15];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 16];
       #"P_Faceplate_LockID" := #MyDInt;    //EPICSName: P_Faceplate_LockID

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 17];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 18];
       #"P_BlockIcon_LockID" := #MyDInt;    //EPICSName: P_BlockIcon_LockID

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 19];
       #"T_period" := #MyInt;    //EPICSName: T_period

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 20];
       #"F_interval" := #MyInt;    //EPICSName: F_interval

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 21];
       #"F_buffer" := #MyInt;    //EPICSName: F_buffer

       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 22];
       #"F_Enable" := #MyBoolsinWord[8];    //EPICSName: F_Enable
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ICS_EH"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpMode_Auto" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Auto
      "OpMode_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Manual
      "OpMode_Forced" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Forced
      "HeaterCurrent" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: HeaterCurrent
      "HeaterVoltage" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: HeaterVoltage
      "HeaterPower" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: HeaterPower
      "HeaterSP" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: HeaterSP
      "HeaterMV" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: HeaterMV
      "HeatingON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HeatingON
      "Inhibit_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Manual
      "Inhibit_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Force
      "Inhibit_Lock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Lock
      "GroupInterlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupInterlock
      "HeatInterlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HeatInterlock
      "EnableAutoBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableAutoBtn
      "EnableManualBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableManualBtn
      "EnableForcedBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForcedBtn
      "EnableForceValBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForceValBtn
      "DevLocked" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DevLocked
      "Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: Faceplate_LockID
      "BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: BlockIcon_LockID
      "LatchAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LatchAlarm
      "GroupAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupAlarm
      "Power_Discrep" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Power_Discrep
      "IO_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IO_Error
      "Input_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Input_Module_Error
      "Output_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Output_Module_Error
      "DiscrPerc" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: DiscrPerc
      "DiscrTime" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : TIME;   //EPICS Status variable: DiscrTime
      "MaxRampUPSpd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MaxRampUPSpd
      "MaxRampDNSpd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MaxRampDNSpd
      "ActRampSpeed" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ActRampSpeed
      "Ramping" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Ramping
      "RampSettingOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RampSettingOK
      "FB_RampUPTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: FB_RampUPTIME
      "FB_RampUPRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_RampUPRANGE
      "FB_RampDNTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: FB_RampDNTIME
      "FB_RampDNRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_RampDNRANGE
      "FB_ForcePower" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_ForcePower
      "FB_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Setpoint
      "FB_Manipulated" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Manipulated
      "FB_Step" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Step
      "FB_RampTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: FB_RampTIME
      "FB_RampRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_RampRANGE
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_Auto" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Auto
      "Cmd_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Manual
      "Cmd_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Force
      "Cmd_RampON" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_RampON
      "Cmd_RampOFF" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_RampOFF
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      "Cmd_ForceValInp" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceValInp
      "Cmd_ForceValOut" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceValOut
      "Cmd_ForceUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceUnlock
      "Cmd_DevLock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevLock
      "Cmd_DevUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevUnlock
      "P_ForcePower" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_ForcePower
      "P_Setpoint" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Setpoint
      "P_Manipulated" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Manipulated
      "P_Step" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Step
      "P_RampUPTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: P_RampUPTIME
      "P_RampUPRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_RampUPRANGE
      "P_RampDNTIME" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: P_RampDNTIME
      "P_RampDNRANGE" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_RampDNRANGE
      "P_Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_Faceplate_LockID
      "P_BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_BlockIcon_LockID
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: ICS_EH
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //##################################### ICS HWI ###############################################
       //############################  ICS Instrument Library     ####################################
       //#  PLC Sample Code in VersionDog: ICS_LIBRARY_MASTER_PLC                                   ##
       //#  CCDB device types: ICS_xxxxx                                                            ##
       //#  EPICS HMI (Block Icons/Faceplates)@ GitLab. Projekt: Cryo / CryogenicsLibrary / CryoLib ##
       //#                                                                                          ##
       //#                                     EH - Alalog Heater                                   ##
       //#                                                                                          ##
       //#                                                                                          ##
       //###########################         Version: 1.3             ################################
       //Author:  Miklos Boros
       //Date:    27-05-2019
       //Version: v1.3
       //Changes:
       //1. Variable name unification
       //###########################         Version: 1.2             ################################
       //Author:  Miklos Boros
       //Date:    28-02-2019
       //Version: v1.2
       //Changes:
       //1. Major review,
       //2. Indent,  unit standardization
       //###########################           Version: 1.1           ################################
       //Author:  Marino Vojneski
       //Date:    2018-07-09
       //Version: v1.1
       //Changes:
       //1. Modified "For OPI visualisation" section: Added digital variable "FB_Keep_Setpoint".
       //2. Modified "Parameter Block" section: Added digital variable "P_Keep_Setpoint".
       //###########################           Version: 1.0           ################################
       //Author:  Miklos Boros, Marino Vojneski
       //Date:    2018-06-12
       //Version: v1.0
       //#############################################################################################
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons
       //Setpoint and Manipulated value from HMI

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpMode_Auto";    //EPICSName: OpMode_Auto
       #MyBoolsinWord[9] := #"OpMode_Manual";    //EPICSName: OpMode_Manual
       #MyBoolsinWord[10] := #"OpMode_Forced";    //EPICSName: OpMode_Forced
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyReal := #"HeaterCurrent";    //EPICSName: HeaterCurrent
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWordsinReal[1];

       #MyReal := #"HeaterVoltage";    //EPICSName: HeaterVoltage
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWordsinReal[1];

       #MyReal := #"HeaterPower";    //EPICSName: HeaterPower
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWordsinReal[1];

       #MyReal := #"HeaterSP";    //EPICSName: HeaterSP
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 8] := #MyWordsinReal[1];

       #MyReal := #"HeaterMV";    //EPICSName: HeaterMV
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 9] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 10] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"HeatingON";    //EPICSName: HeatingON
       #MyBoolsinWord[9] := #"Inhibit_Manual";    //EPICSName: Inhibit_Manual
       #MyBoolsinWord[10] := #"Inhibit_Force";    //EPICSName: Inhibit_Force
       #MyBoolsinWord[11] := #"Inhibit_Lock";    //EPICSName: Inhibit_Lock
       #MyBoolsinWord[12] := #"GroupInterlock";    //EPICSName: GroupInterlock
       #MyBoolsinWord[13] := #"HeatInterlock";    //EPICSName: HeatInterlock
       #MyBoolsinWord[14] := #"EnableAutoBtn";    //EPICSName: EnableAutoBtn
       #MyBoolsinWord[15] := #"EnableManualBtn";    //EPICSName: EnableManualBtn
       #MyBoolsinWord[0] := #"EnableForcedBtn";    //EPICSName: EnableForcedBtn
       #MyBoolsinWord[1] := #"EnableForceValBtn";    //EPICSName: EnableForceValBtn
       #MyBoolsinWord[2] := #"DevLocked";    //EPICSName: DevLocked
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 11] := #MyWord;

       #MyDInt := #"Faceplate_LockID";    //EPICSName: Faceplate_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 12] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 13] := #MyWordsinDint[1];

       #MyDInt := #"BlockIcon_LockID";    //EPICSName: BlockIcon_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 14] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 15] := #MyWordsinDint[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LatchAlarm";    //EPICSName: LatchAlarm
       #MyBoolsinWord[9] := #"GroupAlarm";    //EPICSName: GroupAlarm
       #MyBoolsinWord[10] := #"Power_Discrep";    //EPICSName: Power_Discrep
       #MyBoolsinWord[11] := #"IO_Error";    //EPICSName: IO_Error
       #MyBoolsinWord[12] := #"Input_Module_Error";    //EPICSName: Input_Module_Error
       #MyBoolsinWord[13] := #"Output_Module_Error";    //EPICSName: Output_Module_Error
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 16] := #MyWord;

       #MyReal := #"DiscrPerc";    //EPICSName: DiscrPerc
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 17] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 18] := #MyWordsinReal[1];

       #MyTime := #"DiscrTime";    //EPICSName: DiscrTime
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 19] := #MyWordsinTime[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 20] := #MyWordsinTime[1];

       #MyReal := #"MaxRampUPSpd";    //EPICSName: MaxRampUPSpd
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 21] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 22] := #MyWordsinReal[1];

       #MyReal := #"MaxRampDNSpd";    //EPICSName: MaxRampDNSpd
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 23] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 24] := #MyWordsinReal[1];

       #MyReal := #"ActRampSpeed";    //EPICSName: ActRampSpeed
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 25] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 26] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Ramping";    //EPICSName: Ramping
       #MyBoolsinWord[9] := #"RampSettingOK";    //EPICSName: RampSettingOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 27] := #MyWord;

       #MyInt := #"FB_RampUPTIME";    //EPICSName: FB_RampUPTIME
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 28] := #MyWordinInt;

       #MyReal := #"FB_RampUPRANGE";    //EPICSName: FB_RampUPRANGE
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 29] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 30] := #MyWordsinReal[1];

       #MyInt := #"FB_RampDNTIME";    //EPICSName: FB_RampDNTIME
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 31] := #MyWordinInt;

       #MyReal := #"FB_RampDNRANGE";    //EPICSName: FB_RampDNRANGE
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 32] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 33] := #MyWordsinReal[1];

       #MyReal := #"FB_ForcePower";    //EPICSName: FB_ForcePower
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 34] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 35] := #MyWordsinReal[1];

       #MyReal := #"FB_Setpoint";    //EPICSName: FB_Setpoint
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 36] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 37] := #MyWordsinReal[1];

       #MyReal := #"FB_Manipulated";    //EPICSName: FB_Manipulated
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 38] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 39] := #MyWordsinReal[1];

       #MyReal := #"FB_Step";    //EPICSName: FB_Step
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 40] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 41] := #MyWordsinReal[1];

       #MyInt := #"FB_RampTIME";    //EPICSName: FB_RampTIME
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 42] := #MyWordinInt;

       #MyReal := #"FB_RampRANGE";    //EPICSName: FB_RampRANGE
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 43] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 44] := #MyWordsinReal[1];

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_Auto" := #MyBoolsinWord[8];    //EPICSName: Cmd_Auto
       #"Cmd_Manual" := #MyBoolsinWord[9];    //EPICSName: Cmd_Manual
       #"Cmd_Force" := #MyBoolsinWord[10];    //EPICSName: Cmd_Force
       #"Cmd_RampON" := #MyBoolsinWord[11];    //EPICSName: Cmd_RampON
       #"Cmd_RampOFF" := #MyBoolsinWord[12];    //EPICSName: Cmd_RampOFF
       #"Cmd_AckAlarm" := #MyBoolsinWord[13];    //EPICSName: Cmd_AckAlarm
       #"Cmd_ForceValInp" := #MyBoolsinWord[14];    //EPICSName: Cmd_ForceValInp
       #"Cmd_ForceValOut" := #MyBoolsinWord[15];    //EPICSName: Cmd_ForceValOut
       #"Cmd_ForceUnlock" := #MyBoolsinWord[0];    //EPICSName: Cmd_ForceUnlock
       #"Cmd_DevLock" := #MyBoolsinWord[1];    //EPICSName: Cmd_DevLock
       #"Cmd_DevUnlock" := #MyBoolsinWord[2];    //EPICSName: Cmd_DevUnlock

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"P_ForcePower" := #MyReal;    //EPICSName: P_ForcePower

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 4];
       #"P_Setpoint" := #MyReal;    //EPICSName: P_Setpoint

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 5];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 6];
       #"P_Manipulated" := #MyReal;    //EPICSName: P_Manipulated

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 7];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 8];
       #"P_Step" := #MyReal;    //EPICSName: P_Step

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 9];
       #"P_RampUPTIME" := #MyInt;    //EPICSName: P_RampUPTIME

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 10];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 11];
       #"P_RampUPRANGE" := #MyReal;    //EPICSName: P_RampUPRANGE

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 12];
       #"P_RampDNTIME" := #MyInt;    //EPICSName: P_RampDNTIME

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 13];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 14];
       #"P_RampDNRANGE" := #MyReal;    //EPICSName: P_RampDNRANGE

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 15];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 16];
       #"P_Faceplate_LockID" := #MyDInt;    //EPICSName: P_Faceplate_LockID

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 17];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 18];
       #"P_BlockIcon_LockID" := #MyDInt;    //EPICSName: P_BlockIcon_LockID
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ICS_HV"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpMode_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_FreeRun
      "OpMode_Forced" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Forced
      "Opened" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Opened
      "Closed" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Closed
      "ValveColor" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: ValveColor
      "Inhibit_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Manual
      "Inhibit_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Force
      "Inhibit_Lock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Lock
      "EnableFreeRunBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableFreeRunBtn
      "EnableManualBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableManualBtn
      "EnableForcedBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForcedBtn
      "DevLocked" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DevLocked
      "Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: Faceplate_LockID
      "BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: BlockIcon_LockID
      "LatchAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LatchAlarm
      "GroupAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupAlarm
      "IO_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IO_Error
      "Input_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Input_Module_Error
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_FreeRun
      "Cmd_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Force
      "Cmd_ForceVal" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceVal
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      "Cmd_ForceUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceUnlock
      "Cmd_DevLock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevLock
      "Cmd_DevUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevUnlock
      "P_Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_Faceplate_LockID
      "P_BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_BlockIcon_LockID
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: ICS_HV
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //##################################### ICS HWI ###############################################
       //############################  ICS Instrument Library     ####################################
       //#  PLC Sample Code in VersionDog: ICS_LIBRARY_MASTER_PLC                                   ##
       //#  CCDB device types: ICS_xxxxx                                                            ##
       //#  EPICS HMI (Block Icons/Faceplates)@ GitLab. Projekt: Cryo / CryogenicsLibrary / CryoLib ##
       //#                                                                                          ##
       //#                          HV - Hand valve with position feedback
       //#                                                                                          ##
       //#                                                                                          ##
       //###########################         Version: 1.3             ################################
       //Author:  Miklos Boros
       //Date:    27-05-2019
       //Version: v1.3
       //Changes:
       //1. Variable Name Unification
       //###########################         Version: 1.0, 1.1, 1.2             ######################
       //Author:  Miklos Boros
       //Date:    28-02-2019
       //Version: v1.2
       //Changes:
       //1. Major review,
       //2. Indent,  unit standardization
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons
       //Locking mechanism

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpMode_FreeRun";    //EPICSName: OpMode_FreeRun
       #MyBoolsinWord[9] := #"OpMode_Forced";    //EPICSName: OpMode_Forced
       #MyBoolsinWord[10] := #"Opened";    //EPICSName: Opened
       #MyBoolsinWord[11] := #"Closed";    //EPICSName: Closed
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyInt := #"ValveColor";    //EPICSName: ValveColor
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordinInt;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Inhibit_Manual";    //EPICSName: Inhibit_Manual
       #MyBoolsinWord[9] := #"Inhibit_Force";    //EPICSName: Inhibit_Force
       #MyBoolsinWord[10] := #"Inhibit_Lock";    //EPICSName: Inhibit_Lock
       #MyBoolsinWord[11] := #"EnableFreeRunBtn";    //EPICSName: EnableFreeRunBtn
       #MyBoolsinWord[12] := #"EnableManualBtn";    //EPICSName: EnableManualBtn
       #MyBoolsinWord[13] := #"EnableForcedBtn";    //EPICSName: EnableForcedBtn
       #MyBoolsinWord[14] := #"DevLocked";    //EPICSName: DevLocked
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWord;

       #MyDInt := #"Faceplate_LockID";    //EPICSName: Faceplate_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWordsinDint[1];

       #MyDInt := #"BlockIcon_LockID";    //EPICSName: BlockIcon_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWordsinDint[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LatchAlarm";    //EPICSName: LatchAlarm
       #MyBoolsinWord[9] := #"GroupAlarm";    //EPICSName: GroupAlarm
       #MyBoolsinWord[10] := #"IO_Error";    //EPICSName: IO_Error
       #MyBoolsinWord[11] := #"Input_Module_Error";    //EPICSName: Input_Module_Error
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_FreeRun" := #MyBoolsinWord[8];    //EPICSName: Cmd_FreeRun
       #"Cmd_Force" := #MyBoolsinWord[9];    //EPICSName: Cmd_Force
       #"Cmd_ForceVal" := #MyBoolsinWord[10];    //EPICSName: Cmd_ForceVal
       #"Cmd_AckAlarm" := #MyBoolsinWord[11];    //EPICSName: Cmd_AckAlarm
       #"Cmd_ForceUnlock" := #MyBoolsinWord[12];    //EPICSName: Cmd_ForceUnlock
       #"Cmd_DevLock" := #MyBoolsinWord[13];    //EPICSName: Cmd_DevLock
       #"Cmd_DevUnlock" := #MyBoolsinWord[14];    //EPICSName: Cmd_DevUnlock

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"P_Faceplate_LockID" := #MyDInt;    //EPICSName: P_Faceplate_LockID

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 4];
       #"P_BlockIcon_LockID" := #MyDInt;    //EPICSName: P_BlockIcon_LockID
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ICS_LAKESHORE_TT"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpMode_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_FreeRun
      "OpMode_Forced" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Forced
      "Inhibit_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Manual
      "Inhibit_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Force
      "Inhibit_Lock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Lock
      "TransmitterColor" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: TransmitterColor
      "MinTemp" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MinTemp
      "MaxTemp" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MaxTemp
      "EnableFreeRunBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableFreeRunBtn
      "EnableForcedBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForcedBtn
      "EnableManualBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableManualBtn
      "MeasValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MeasValue
      "DevLocked" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DevLocked
      "Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: Faceplate_LockID
      "BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: BlockIcon_LockID
      "LatchAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LatchAlarm
      "GroupAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupAlarm
      "Underrange" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Underrange
      "Overrange" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Overrange
      "HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HIHI
      "HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HI
      "LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LO
      "LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LOLO
      "Param_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Param_Error
      "PN_Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PN_Module_Error
      "FB_ForceValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_ForceValue
      "FB_Limit_HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_HIHI
      "FB_Limit_HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_HI
      "FB_Limit_LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_LO
      "FB_Limit_LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_LOLO
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_FreeRun
      "Cmd_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Force
      "Cmd_ForceVal" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceVal
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      "Cmd_ForceUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceUnlock
      "Cmd_DevLock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevLock
      "Cmd_DevUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevUnlock
      "P_Limit_HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_HIHI
      "P_Limit_HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_HI
      "P_Limit_LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_LO
      "P_Limit_LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_LOLO
      "P_ForceValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_ForceValue
      "P_Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_Faceplate_LockID
      "P_BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_BlockIcon_LockID
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: ICS_LAKESHORE_TT
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //##################################### ICS HWI ###############################################
       //############################  ICS Instrument Library     ####################################
       //#  PLC Sample Code in VersionDog: ICS_LIBRARY_MASTER_PLC                                   ##
       //#  CCDB device types: ICS_xxxxx                                                            ##
       //#  EPICS HMI (Block Icons/Faceplates)@ GitLab. Projekt: Cryo / CryogenicsLibrary / CryoLib ##
       //#                                                                                          ##
       //#                      TT - Temperature Transmitter in K with Lakeshore                    ##
       //#                                                                                          ##
       //#                                                                                          ##
       //###########################         Version: 1.4             ################################
       //Author:  Miklos Boros
       //Date:    16-12-2019
       //Version: v1.4
       //Changes:
       //1. Modified TT for direct Temp measurement with Lakeshore
       //###########################         Version: 1.3             ################################
       //Author:  Miklos Boros
       //Date:    27-05-2019
       //Version: v1.3
       //Changes:
       //1. Variable Name Unification
       //###########################         Version: 1.2             ################################
       //Author:  Miklos Boros
       //Date:    28-02-2019
       //Version: v1.2
       //Changes:
       //1. Major review,
       //2. Indent,  unit standardization
       //###########################         Version: 1.1             ################################
       //Author:  Miklos Boros, Marino Vojneski
       //Date:    12-06-2018
       //Version: v1.1
       //Changes:
       //1. Modified Alarm Signal section to be compatible with new format.
       //########################### Version: 1.0             ########################################
       //Author:  Miklos Boros
       //Date:    25-01-2018
       //Version: v1.0
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons
       //Limits

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpMode_FreeRun";    //EPICSName: OpMode_FreeRun
       #MyBoolsinWord[9] := #"OpMode_Forced";    //EPICSName: OpMode_Forced
       #MyBoolsinWord[10] := #"Inhibit_Manual";    //EPICSName: Inhibit_Manual
       #MyBoolsinWord[11] := #"Inhibit_Force";    //EPICSName: Inhibit_Force
       #MyBoolsinWord[12] := #"Inhibit_Lock";    //EPICSName: Inhibit_Lock
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyInt := #"TransmitterColor";    //EPICSName: TransmitterColor
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordinInt;

       #MyReal := #"MinTemp";    //EPICSName: MinTemp
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWordsinReal[1];

       #MyReal := #"MaxTemp";    //EPICSName: MaxTemp
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"EnableFreeRunBtn";    //EPICSName: EnableFreeRunBtn
       #MyBoolsinWord[9] := #"EnableForcedBtn";    //EPICSName: EnableForcedBtn
       #MyBoolsinWord[10] := #"EnableManualBtn";    //EPICSName: EnableManualBtn
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWord;

       #MyReal := #"MeasValue";    //EPICSName: MeasValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 8] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"DevLocked";    //EPICSName: DevLocked
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 9] := #MyWord;

       #MyDInt := #"Faceplate_LockID";    //EPICSName: Faceplate_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 10] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 11] := #MyWordsinDint[1];

       #MyDInt := #"BlockIcon_LockID";    //EPICSName: BlockIcon_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 12] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 13] := #MyWordsinDint[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LatchAlarm";    //EPICSName: LatchAlarm
       #MyBoolsinWord[9] := #"GroupAlarm";    //EPICSName: GroupAlarm
       #MyBoolsinWord[10] := #"Underrange";    //EPICSName: Underrange
       #MyBoolsinWord[11] := #"Overrange";    //EPICSName: Overrange
       #MyBoolsinWord[12] := #"HIHI";    //EPICSName: HIHI
       #MyBoolsinWord[13] := #"HI";    //EPICSName: HI
       #MyBoolsinWord[14] := #"LO";    //EPICSName: LO
       #MyBoolsinWord[15] := #"LOLO";    //EPICSName: LOLO
       #MyBoolsinWord[0] := #"Param_Error";    //EPICSName: Param_Error
       #MyBoolsinWord[1] := #"PN_Module_Error";    //EPICSName: PN_Module_Error
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 14] := #MyWord;

       #MyReal := #"FB_ForceValue";    //EPICSName: FB_ForceValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 15] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 16] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_HIHI";    //EPICSName: FB_Limit_HIHI
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 17] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 18] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_HI";    //EPICSName: FB_Limit_HI
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 19] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 20] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_LO";    //EPICSName: FB_Limit_LO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 21] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 22] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_LOLO";    //EPICSName: FB_Limit_LOLO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 23] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 24] := #MyWordsinReal[1];

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_FreeRun" := #MyBoolsinWord[8];    //EPICSName: Cmd_FreeRun
       #"Cmd_Force" := #MyBoolsinWord[9];    //EPICSName: Cmd_Force
       #"Cmd_ForceVal" := #MyBoolsinWord[10];    //EPICSName: Cmd_ForceVal
       #"Cmd_AckAlarm" := #MyBoolsinWord[11];    //EPICSName: Cmd_AckAlarm
       #"Cmd_ForceUnlock" := #MyBoolsinWord[12];    //EPICSName: Cmd_ForceUnlock
       #"Cmd_DevLock" := #MyBoolsinWord[13];    //EPICSName: Cmd_DevLock
       #"Cmd_DevUnlock" := #MyBoolsinWord[14];    //EPICSName: Cmd_DevUnlock

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"P_Limit_HIHI" := #MyReal;    //EPICSName: P_Limit_HIHI

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 4];
       #"P_Limit_HI" := #MyReal;    //EPICSName: P_Limit_HI

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 5];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 6];
       #"P_Limit_LO" := #MyReal;    //EPICSName: P_Limit_LO

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 7];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 8];
       #"P_Limit_LOLO" := #MyReal;    //EPICSName: P_Limit_LOLO

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 9];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 10];
       #"P_ForceValue" := #MyReal;    //EPICSName: P_ForceValue

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 11];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 12];
       #"P_Faceplate_LockID" := #MyDInt;    //EPICSName: P_Faceplate_LockID

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 13];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 14];
       #"P_BlockIcon_LockID" := #MyDInt;    //EPICSName: P_BlockIcon_LockID
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ICS_LT"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpMode_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_FreeRun
      "OpMode_Forced" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Forced
      "Inhibit_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Manual
      "Inhibit_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Force
      "Inhibit_Lock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Lock
      "TransmitterColor" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: TransmitterColor
      "EnableFreeRunBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableFreeRunBtn
      "EnableForcedBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForcedBtn
      "EnableManualBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableManualBtn
      "ScaleLOW" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ScaleLOW
      "ScaleHIGH" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ScaleHIGH
      "MeasValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MeasValue
      "RAWValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: RAWValue
      "DevLocked" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DevLocked
      "Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: Faceplate_LockID
      "BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: BlockIcon_LockID
      "LatchAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LatchAlarm
      "GroupAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupAlarm
      "Underrange" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Underrange
      "Overrange" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Overrange
      "HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HIHI
      "HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HI
      "LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LO
      "LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LOLO
      "IO_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IO_Error
      "Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Module_Error
      "Param_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Param_Error
      "FB_ForceValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_ForceValue
      "FB_Limit_HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_HIHI
      "FB_Limit_HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_HI
      "FB_Limit_LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_LO
      "FB_Limit_LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_LOLO
      "Timer_enabled" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Timer_enabled
      "T_triggered" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: T_triggered
      "T_running" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: T_running
      "F_enabled" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_enabled
      "FiltedValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FiltedValue
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_FreeRun
      "Cmd_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Force
      "Cmd_ForceVal" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceVal
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      "Cmd_ForceUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceUnlock
      "Cmd_DevLock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevLock
      "Cmd_DevUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevUnlock
      "P_Limit_HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_HIHI
      "P_Limit_HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_HI
      "P_Limit_LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_LO
      "P_Limit_LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_LOLO
      "P_ForceValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_ForceValue
      "P_Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_Faceplate_LockID
      "P_BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_BlockIcon_LockID
      "T_period" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: T_period
      "F_interval" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: F_interval
      "F_buffer" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Parameter variable: F_buffer
      "F_Enable" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Parameter variable: F_Enable
      "P_RampUPSpeed" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_RampUPSpeed
      "P_RampDNSpeed" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_RampDNSpeed
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: ICS_LT
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //##################################### ICS HWI ###############################################
       //############################  ICS Instrument Library     ####################################
       //#  PLC Sample Code in VersionDog: ICS_LIBRARY_MASTER_PLC                                   ##
       //#  CCDB device types: ICS_xxxxx                                                            ##
       //#  EPICS HMI (Block Icons/Faceplates)@ GitLab. Projekt: Cryo / CryogenicsLibrary / CryoLib ##
       //#                                                                                          ##
       //#                          LT- Level Transmitter in percent                                ##
       //#                                                                                          ##
       //#                                                                                          ##
       //###########################         Version: 1.4             ################################
       //Author:  Emilio Asensi
       //Date:    06-09-2022
       //Version: v1.4
       //Changes:
       //1. Added pvs for timer, filter and ramping speed
       //###########################         Version: 1.3             ################################
       //Author:  Miklos Boros
       //Date:    27-05-2019
       //Version: v1.3
       //Changes:
       //1. Variable Name Unification
       //###########################         Version: 1.2             ################################
       //Author:  Miklos Boros
       //Date:    28-02-2019
       //Version: v1.2
       //Changes:
       //1. Major review,
       //2. Indent,  unit standardization
       //###########################         Version: 1.1             ################################
       //Author:  Miklos Boros, Marino Vojneski
       //Date:    12-06-2018
       //Version: v1.1
       //Changes:
       //1. Modified Alarm Signal section to be compatible with new format.
       //########################### Version: 1.0             ########################################
       //Author:  Miklos Boros
       //Date:    25-01-2018
       //Version: v1.0
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons
       //Limits

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpMode_FreeRun";    //EPICSName: OpMode_FreeRun
       #MyBoolsinWord[9] := #"OpMode_Forced";    //EPICSName: OpMode_Forced
       #MyBoolsinWord[10] := #"Inhibit_Manual";    //EPICSName: Inhibit_Manual
       #MyBoolsinWord[11] := #"Inhibit_Force";    //EPICSName: Inhibit_Force
       #MyBoolsinWord[12] := #"Inhibit_Lock";    //EPICSName: Inhibit_Lock
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyInt := #"TransmitterColor";    //EPICSName: TransmitterColor
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordinInt;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"EnableFreeRunBtn";    //EPICSName: EnableFreeRunBtn
       #MyBoolsinWord[9] := #"EnableForcedBtn";    //EPICSName: EnableForcedBtn
       #MyBoolsinWord[10] := #"EnableManualBtn";    //EPICSName: EnableManualBtn
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWord;

       #MyReal := #"ScaleLOW";    //EPICSName: ScaleLOW
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWordsinReal[1];

       #MyReal := #"ScaleHIGH";    //EPICSName: ScaleHIGH
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWordsinReal[1];

       #MyReal := #"MeasValue";    //EPICSName: MeasValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 8] := #MyWordsinReal[1];

       #MyReal := #"RAWValue";    //EPICSName: RAWValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 9] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 10] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"DevLocked";    //EPICSName: DevLocked
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 11] := #MyWord;

       #MyDInt := #"Faceplate_LockID";    //EPICSName: Faceplate_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 12] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 13] := #MyWordsinDint[1];

       #MyDInt := #"BlockIcon_LockID";    //EPICSName: BlockIcon_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 14] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 15] := #MyWordsinDint[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LatchAlarm";    //EPICSName: LatchAlarm
       #MyBoolsinWord[9] := #"GroupAlarm";    //EPICSName: GroupAlarm
       #MyBoolsinWord[10] := #"Underrange";    //EPICSName: Underrange
       #MyBoolsinWord[11] := #"Overrange";    //EPICSName: Overrange
       #MyBoolsinWord[12] := #"HIHI";    //EPICSName: HIHI
       #MyBoolsinWord[13] := #"HI";    //EPICSName: HI
       #MyBoolsinWord[14] := #"LO";    //EPICSName: LO
       #MyBoolsinWord[15] := #"LOLO";    //EPICSName: LOLO
       #MyBoolsinWord[0] := #"IO_Error";    //EPICSName: IO_Error
       #MyBoolsinWord[1] := #"Module_Error";    //EPICSName: Module_Error
       #MyBoolsinWord[2] := #"Param_Error";    //EPICSName: Param_Error
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 16] := #MyWord;

       #MyReal := #"FB_ForceValue";    //EPICSName: FB_ForceValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 17] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 18] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_HIHI";    //EPICSName: FB_Limit_HIHI
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 19] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 20] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_HI";    //EPICSName: FB_Limit_HI
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 21] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 22] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_LO";    //EPICSName: FB_Limit_LO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 23] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 24] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_LOLO";    //EPICSName: FB_Limit_LOLO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 25] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 26] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Timer_enabled";    //EPICSName: Timer_enabled
       #MyBoolsinWord[9] := #"T_triggered";    //EPICSName: T_triggered
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 27] := #MyWord;

       #MyInt := #"T_running";    //EPICSName: T_running
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 28] := #MyWordinInt;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"F_enabled";    //EPICSName: F_enabled
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 29] := #MyWord;

       #MyReal := #"FiltedValue";    //EPICSName: FiltedValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 30] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 31] := #MyWordsinReal[1];

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_FreeRun" := #MyBoolsinWord[8];    //EPICSName: Cmd_FreeRun
       #"Cmd_Force" := #MyBoolsinWord[9];    //EPICSName: Cmd_Force
       #"Cmd_ForceVal" := #MyBoolsinWord[10];    //EPICSName: Cmd_ForceVal
       #"Cmd_AckAlarm" := #MyBoolsinWord[11];    //EPICSName: Cmd_AckAlarm
       #"Cmd_ForceUnlock" := #MyBoolsinWord[12];    //EPICSName: Cmd_ForceUnlock
       #"Cmd_DevLock" := #MyBoolsinWord[13];    //EPICSName: Cmd_DevLock
       #"Cmd_DevUnlock" := #MyBoolsinWord[14];    //EPICSName: Cmd_DevUnlock

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"P_Limit_HIHI" := #MyReal;    //EPICSName: P_Limit_HIHI

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 4];
       #"P_Limit_HI" := #MyReal;    //EPICSName: P_Limit_HI

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 5];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 6];
       #"P_Limit_LO" := #MyReal;    //EPICSName: P_Limit_LO

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 7];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 8];
       #"P_Limit_LOLO" := #MyReal;    //EPICSName: P_Limit_LOLO

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 9];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 10];
       #"P_ForceValue" := #MyReal;    //EPICSName: P_ForceValue

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 11];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 12];
       #"P_Faceplate_LockID" := #MyDInt;    //EPICSName: P_Faceplate_LockID

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 13];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 14];
       #"P_BlockIcon_LockID" := #MyDInt;    //EPICSName: P_BlockIcon_LockID

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 15];
       #"T_period" := #MyInt;    //EPICSName: T_period

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 16];
       #"F_interval" := #MyInt;    //EPICSName: F_interval

       #MyWordinInt := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 17];
       #"F_buffer" := #MyInt;    //EPICSName: F_buffer

       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 18];
       #"F_Enable" := #MyBoolsinWord[8];    //EPICSName: F_Enable

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 19];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 20];
       #"P_RampUPSpeed" := #MyReal;    //EPICSName: P_RampUPSpeed

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 21];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 22];
       #"P_RampDNSpeed" := #MyReal;    //EPICSName: P_RampDNSpeed
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ICS_PT_mbar"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpMode_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_FreeRun
      "OpMode_Forced" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpMode_Forced
      "Inhibit_Manual" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Manual
      "Inhibit_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Force
      "Inhibit_Lock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Inhibit_Lock
      "TransmitterColor" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : INT;   //EPICS Status variable: TransmitterColor
      "EnableFreeRunBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableFreeRunBtn
      "EnableManualBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableManualBtn
      "EnableForcedBtn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnableForcedBtn
      "ScaleLOW" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ScaleLOW
      "ScaleHIGH" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: ScaleHIGH
      "MeasValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: MeasValue
      "DevLocked" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DevLocked
      "Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: Faceplate_LockID
      "BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Status variable: BlockIcon_LockID
      "LatchAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LatchAlarm
      "GroupAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GroupAlarm
      "Underrange" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Underrange
      "Overrange" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Overrange
      "HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HIHI
      "HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HI
      "LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LO
      "LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LOLO
      "IO_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IO_Error
      "Module_Error" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Module_Error
      "FB_ForceValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_ForceValue
      "FB_Limit_HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_HIHI
      "FB_Limit_HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_HI
      "FB_Limit_LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_LO
      "FB_Limit_LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: FB_Limit_LOLO
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "Cmd_FreeRun" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_FreeRun
      "Cmd_Force" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_Force
      "Cmd_ForceVal" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceVal
      "Cmd_AckAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_AckAlarm
      "Cmd_ForceUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_ForceUnlock
      "Cmd_DevLock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevLock
      "Cmd_DevUnlock" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: Cmd_DevUnlock
      "P_Limit_HIHI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_HIHI
      "P_Limit_HI" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_HI
      "P_Limit_LO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_LO
      "P_Limit_LOLO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_Limit_LOLO
      "P_ForceValue" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: P_ForceValue
      "P_Faceplate_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_Faceplate_LockID
      "P_BlockIcon_LockID" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DINT;   //EPICS Parameter variable: P_BlockIcon_LockID
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: Spk-000CDL_Cryo-PLC-010-template-IFA-20220922093722.ifa
    //Generated: 20220922093722
    //According to HASH: 457744924
    //Device type: ICS_PT_mbar
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 457744924; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //##################################### ICS HWI ###############################################
       //############################  ICS Instrument Library     ####################################
       //#  PLC Sample Code in VersionDog: ICS_LIBRARY_MASTER_PLC                                   ##
       //#  CCDB device types: ICS_xxxxx                                                            ##
       //#  EPICS HMI (Block Icons/Faceplates)@ GitLab. Projekt: Cryo / CryogenicsLibrary / CryoLib ##
       //#                                                                                          ##
       //#                             PT - Pressure Transmitter in mbar                            ##
       //#                                                                                          ##
       //#                                                                                          ##
       //###########################         Version: 1.3             ################################
       //Author:  Miklos Boros
       //Date:    27-05-2019
       //Version: v1.3
       //Changes:
       //1. Variable Name Unification
       //###########################         Version: 1.2             ################################
       //Author:  Miklos Boros
       //Date:    28-02-2019
       //Version: v1.2
       //Changes:
       //1. Major review,
       //2. Indent,  unit standardization
       //###########################         Version: 1.1             ################################
       //Author:  Miklos Boros, Marino Vojneski
       //Date:    12-06-2018
       //Version: v1.1
       //Changes:
       //1. Modified Alarm Signal section to be compatible with new format.
       //########################### Version: 1.0             ########################################
       //Author:  Miklos Boros
       //Date:    25-01-2018
       //Version: v1.0
       //###########################
       //STATUS BLOCK
       //###########################
       //Operation modes
       //OPI buttons
       //Limits

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpMode_FreeRun";    //EPICSName: OpMode_FreeRun
       #MyBoolsinWord[9] := #"OpMode_Forced";    //EPICSName: OpMode_Forced
       #MyBoolsinWord[10] := #"Inhibit_Manual";    //EPICSName: Inhibit_Manual
       #MyBoolsinWord[11] := #"Inhibit_Force";    //EPICSName: Inhibit_Force
       #MyBoolsinWord[12] := #"Inhibit_Lock";    //EPICSName: Inhibit_Lock
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyInt := #"TransmitterColor";    //EPICSName: TransmitterColor
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordinInt;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"EnableFreeRunBtn";    //EPICSName: EnableFreeRunBtn
       #MyBoolsinWord[9] := #"EnableManualBtn";    //EPICSName: EnableManualBtn
       #MyBoolsinWord[10] := #"EnableForcedBtn";    //EPICSName: EnableForcedBtn
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWord;

       #MyReal := #"ScaleLOW";    //EPICSName: ScaleLOW
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWordsinReal[1];

       #MyReal := #"ScaleHIGH";    //EPICSName: ScaleHIGH
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWordsinReal[1];

       #MyReal := #"MeasValue";    //EPICSName: MeasValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 8] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"DevLocked";    //EPICSName: DevLocked
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 9] := #MyWord;

       #MyDInt := #"Faceplate_LockID";    //EPICSName: Faceplate_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 10] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 11] := #MyWordsinDint[1];

       #MyDInt := #"BlockIcon_LockID";    //EPICSName: BlockIcon_LockID
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 12] := #MyWordsinDint[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 13] := #MyWordsinDint[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LatchAlarm";    //EPICSName: LatchAlarm
       #MyBoolsinWord[9] := #"GroupAlarm";    //EPICSName: GroupAlarm
       #MyBoolsinWord[10] := #"Underrange";    //EPICSName: Underrange
       #MyBoolsinWord[11] := #"Overrange";    //EPICSName: Overrange
       #MyBoolsinWord[12] := #"HIHI";    //EPICSName: HIHI
       #MyBoolsinWord[13] := #"HI";    //EPICSName: HI
       #MyBoolsinWord[14] := #"LO";    //EPICSName: LO
       #MyBoolsinWord[15] := #"LOLO";    //EPICSName: LOLO
       #MyBoolsinWord[0] := #"IO_Error";    //EPICSName: IO_Error
       #MyBoolsinWord[1] := #"Module_Error";    //EPICSName: Module_Error
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 14] := #MyWord;

       #MyReal := #"FB_ForceValue";    //EPICSName: FB_ForceValue
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 15] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 16] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_HIHI";    //EPICSName: FB_Limit_HIHI
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 17] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 18] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_HI";    //EPICSName: FB_Limit_HI
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 19] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 20] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_LO";    //EPICSName: FB_Limit_LO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 21] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 22] := #MyWordsinReal[1];

       #MyReal := #"FB_Limit_LOLO";    //EPICSName: FB_Limit_LOLO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 23] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 24] := #MyWordsinReal[1];

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       #"Cmd_FreeRun" := #MyBoolsinWord[8];    //EPICSName: Cmd_FreeRun
       #"Cmd_Force" := #MyBoolsinWord[9];    //EPICSName: Cmd_Force
       #"Cmd_ForceVal" := #MyBoolsinWord[10];    //EPICSName: Cmd_ForceVal
       #"Cmd_AckAlarm" := #MyBoolsinWord[11];    //EPICSName: Cmd_AckAlarm
       #"Cmd_ForceUnlock" := #MyBoolsinWord[12];    //EPICSName: Cmd_ForceUnlock
       #"Cmd_DevLock" := #MyBoolsinWord[13];    //EPICSName: Cmd_DevLock
       #"Cmd_DevUnlock" := #MyBoolsinWord[14];    //EPICSName: Cmd_DevUnlock

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"P_Limit_HIHI" := #MyReal;    //EPICSName: P_Limit_HIHI

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 4];
       #"P_Limit_HI" := #MyReal;    //EPICSName: P_Limit_HI

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 5];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 6];
       #"P_Limit_LO" := #MyReal;    //EPICSName: P_Limit_LO

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 7];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 8];
       #"P_Limit_LOLO" := #MyReal;    //EPICSName: P_Limit_LOLO

       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 9];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 10];
       #"P_ForceValue" := #MyReal;    //EPICSName: P_ForceValue

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 11];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 12];
       #"P_Faceplate_LockID" := #MyDInt;    //EPICSName: P_Faceplate_LockID

       #MyDInt	:= 0;
       #MyWordsinDint[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 13];
       #MyWordsinDint[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 14];
       #"P_BlockIcon_LockID" := #MyDInt;    //EPICSName: P_BlockIcon_LockID
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK

DATA_BLOCK "DEV_Spk-000CDL:SC-FSM-300_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_AUTO_CONF"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:SC-FSM-400_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_DIAG"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:SC-FSM-500_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_INTLCK"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:SC-FSM-600_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_MODE_SEL"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PID-91_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_PID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PID-92_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_PID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PID-93_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_PID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PID-94_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_C3S_PID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-CV-91_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_CV_PB_SIPART"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-CV-92_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_CV_PB_SIPART"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-CV-93_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_CV_PB_SIPART"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-CV-94_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_CV_PB_SIPART"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-EH-91_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_EH"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-EH-92_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_EH"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-EH-93_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_EH"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-EH-94_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_EH"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-EH-95_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_EH"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-EH-96_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_EH"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-HV-70_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_HV"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-HV-73_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_HV"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-91_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-92_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-93_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-94_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-95_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-96_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-97_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-TT-98_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LAKESHORE_TT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-LT-91_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-LT-92_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_LT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PT-91_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_PT_mbar"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PT-92_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_PT_mbar"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PT-93_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_PT_mbar"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PT-94_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_PT_mbar"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Cryo-PT-95_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_PT_mbar"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Vac-VGC-071_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_PT_mbar"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_Spk-000CDL:Vac-VGP-070_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ICS_PT_mbar"
BEGIN
END_DATA_BLOCK

FUNCTION "EPICS_device_calls" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0

   VAR_TEMP
      "Spk-000CDL:SC-FSM-300" : Bool;   // HASH codes are OK
      "Spk-000CDL:SC-FSM-400" : Bool;   // HASH codes are OK
      "Spk-000CDL:SC-FSM-500" : Bool;   // HASH codes are OK
      "Spk-000CDL:SC-FSM-600" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PID-91" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PID-92" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PID-93" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PID-94" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-CV-91" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-CV-92" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-CV-93" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-CV-94" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-EH-91" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-EH-92" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-EH-93" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-EH-94" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-EH-95" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-EH-96" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-HV-70" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-HV-73" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-91" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-92" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-93" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-94" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-95" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-96" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-97" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-TT-98" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-LT-91" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-LT-92" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PT-91" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PT-92" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PT-93" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PT-94" : Bool;   // HASH codes are OK
      "Spk-000CDL:Cryo-PT-95" : Bool;   // HASH codes are OK
      "Spk-000CDL:Vac-VGC-071" : Bool;   // HASH codes are OK
      "Spk-000CDL:Vac-VGP-070" : Bool;   // HASH codes are OK
   END_VAR

BEGIN
      //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
      //This block was generated by PLCFactory
      //According to HASH:457744924
      //Description: Description: This function calls the devices according to the corresponding device type

        //DO NOT Modify the following line!!!
        "Utilities".TestInProgress := FALSE;
        "Utilities".EPICS_Device_calls_precessed := TRUE;


        //********************************************
        // Device name: Spk-000CDL:SC-FSM-300
        // Device type: C3S_AUTO_CONF
        //********************************************

      "DEV_Spk-000CDL:SC-FSM-300_iDB" (EPICSToPLCLength:=73,
      EPICSToPLCDataBlockOffset:=10,
      PLCToEPICSLength:=73,
      PLCToEPICSDataBlockOffset:=10);

        //********************************************
        // Device name: Spk-000CDL:SC-FSM-400
        // Device type: C3S_DIAG
        //********************************************

      "DEV_Spk-000CDL:SC-FSM-400_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=83,
      PLCToEPICSLength:=8,
      PLCToEPICSDataBlockOffset:=83);

        //********************************************
        // Device name: Spk-000CDL:SC-FSM-500
        // Device type: C3S_INTLCK
        //********************************************

      "DEV_Spk-000CDL:SC-FSM-500_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=84,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=91);

        //********************************************
        // Device name: Spk-000CDL:SC-FSM-600
        // Device type: C3S_MODE_SEL
        //********************************************

      "DEV_Spk-000CDL:SC-FSM-600_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=85,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=92);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PID-91
        // Device type: C3S_PID
        //********************************************

      "DEV_Spk-000CDL:Cryo-PID-91_iDB" (EPICSToPLCLength:=26,
      EPICSToPLCDataBlockOffset:=86,
      PLCToEPICSLength:=90,
      PLCToEPICSDataBlockOffset:=117);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PID-92
        // Device type: C3S_PID
        //********************************************

      "DEV_Spk-000CDL:Cryo-PID-92_iDB" (EPICSToPLCLength:=26,
      EPICSToPLCDataBlockOffset:=112,
      PLCToEPICSLength:=90,
      PLCToEPICSDataBlockOffset:=207);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PID-93
        // Device type: C3S_PID
        //********************************************

      "DEV_Spk-000CDL:Cryo-PID-93_iDB" (EPICSToPLCLength:=26,
      EPICSToPLCDataBlockOffset:=138,
      PLCToEPICSLength:=90,
      PLCToEPICSDataBlockOffset:=297);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PID-94
        // Device type: C3S_PID
        //********************************************

      "DEV_Spk-000CDL:Cryo-PID-94_iDB" (EPICSToPLCLength:=26,
      EPICSToPLCDataBlockOffset:=164,
      PLCToEPICSLength:=90,
      PLCToEPICSDataBlockOffset:=387);

        //********************************************
        // Device name: Spk-000CDL:Cryo-CV-91
        // Device type: ICS_CV_PB_SIPART
        //********************************************

      "DEV_Spk-000CDL:Cryo-CV-91_iDB" (EPICSToPLCLength:=23,
      EPICSToPLCDataBlockOffset:=190,
      PLCToEPICSLength:=75,
      PLCToEPICSDataBlockOffset:=477);

        //********************************************
        // Device name: Spk-000CDL:Cryo-CV-92
        // Device type: ICS_CV_PB_SIPART
        //********************************************

      "DEV_Spk-000CDL:Cryo-CV-92_iDB" (EPICSToPLCLength:=23,
      EPICSToPLCDataBlockOffset:=213,
      PLCToEPICSLength:=75,
      PLCToEPICSDataBlockOffset:=552);

        //********************************************
        // Device name: Spk-000CDL:Cryo-CV-93
        // Device type: ICS_CV_PB_SIPART
        //********************************************

      "DEV_Spk-000CDL:Cryo-CV-93_iDB" (EPICSToPLCLength:=23,
      EPICSToPLCDataBlockOffset:=236,
      PLCToEPICSLength:=75,
      PLCToEPICSDataBlockOffset:=627);

        //********************************************
        // Device name: Spk-000CDL:Cryo-CV-94
        // Device type: ICS_CV_PB_SIPART
        //********************************************

      "DEV_Spk-000CDL:Cryo-CV-94_iDB" (EPICSToPLCLength:=23,
      EPICSToPLCDataBlockOffset:=259,
      PLCToEPICSLength:=75,
      PLCToEPICSDataBlockOffset:=702);

        //********************************************
        // Device name: Spk-000CDL:Cryo-EH-91
        // Device type: ICS_EH
        //********************************************

      "DEV_Spk-000CDL:Cryo-EH-91_iDB" (EPICSToPLCLength:=19,
      EPICSToPLCDataBlockOffset:=282,
      PLCToEPICSLength:=45,
      PLCToEPICSDataBlockOffset:=777);

        //********************************************
        // Device name: Spk-000CDL:Cryo-EH-92
        // Device type: ICS_EH
        //********************************************

      "DEV_Spk-000CDL:Cryo-EH-92_iDB" (EPICSToPLCLength:=19,
      EPICSToPLCDataBlockOffset:=301,
      PLCToEPICSLength:=45,
      PLCToEPICSDataBlockOffset:=822);

        //********************************************
        // Device name: Spk-000CDL:Cryo-EH-93
        // Device type: ICS_EH
        //********************************************

      "DEV_Spk-000CDL:Cryo-EH-93_iDB" (EPICSToPLCLength:=19,
      EPICSToPLCDataBlockOffset:=320,
      PLCToEPICSLength:=45,
      PLCToEPICSDataBlockOffset:=867);

        //********************************************
        // Device name: Spk-000CDL:Cryo-EH-94
        // Device type: ICS_EH
        //********************************************

      "DEV_Spk-000CDL:Cryo-EH-94_iDB" (EPICSToPLCLength:=19,
      EPICSToPLCDataBlockOffset:=339,
      PLCToEPICSLength:=45,
      PLCToEPICSDataBlockOffset:=912);

        //********************************************
        // Device name: Spk-000CDL:Cryo-EH-95
        // Device type: ICS_EH
        //********************************************

      "DEV_Spk-000CDL:Cryo-EH-95_iDB" (EPICSToPLCLength:=19,
      EPICSToPLCDataBlockOffset:=358,
      PLCToEPICSLength:=45,
      PLCToEPICSDataBlockOffset:=957);

        //********************************************
        // Device name: Spk-000CDL:Cryo-EH-96
        // Device type: ICS_EH
        //********************************************

      "DEV_Spk-000CDL:Cryo-EH-96_iDB" (EPICSToPLCLength:=19,
      EPICSToPLCDataBlockOffset:=377,
      PLCToEPICSLength:=45,
      PLCToEPICSDataBlockOffset:=1002);

        //********************************************
        // Device name: Spk-000CDL:Cryo-HV-70
        // Device type: ICS_HV
        //********************************************

      "DEV_Spk-000CDL:Cryo-HV-70_iDB" (EPICSToPLCLength:=5,
      EPICSToPLCDataBlockOffset:=396,
      PLCToEPICSLength:=8,
      PLCToEPICSDataBlockOffset:=1047);

        //********************************************
        // Device name: Spk-000CDL:Cryo-HV-73
        // Device type: ICS_HV
        //********************************************

      "DEV_Spk-000CDL:Cryo-HV-73_iDB" (EPICSToPLCLength:=5,
      EPICSToPLCDataBlockOffset:=401,
      PLCToEPICSLength:=8,
      PLCToEPICSDataBlockOffset:=1055);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-91
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-91_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=406,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1063);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-92
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-92_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=421,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1088);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-93
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-93_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=436,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1113);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-94
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-94_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=451,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1138);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-95
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-95_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=466,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1163);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-96
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-96_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=481,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1188);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-97
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-97_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=496,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1213);

        //********************************************
        // Device name: Spk-000CDL:Cryo-TT-98
        // Device type: ICS_LAKESHORE_TT
        //********************************************

      "DEV_Spk-000CDL:Cryo-TT-98_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=511,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1238);

        //********************************************
        // Device name: Spk-000CDL:Cryo-LT-91
        // Device type: ICS_LT
        //********************************************

      "DEV_Spk-000CDL:Cryo-LT-91_iDB" (EPICSToPLCLength:=23,
      EPICSToPLCDataBlockOffset:=526,
      PLCToEPICSLength:=32,
      PLCToEPICSDataBlockOffset:=1263);

        //********************************************
        // Device name: Spk-000CDL:Cryo-LT-92
        // Device type: ICS_LT
        //********************************************

      "DEV_Spk-000CDL:Cryo-LT-92_iDB" (EPICSToPLCLength:=23,
      EPICSToPLCDataBlockOffset:=549,
      PLCToEPICSLength:=32,
      PLCToEPICSDataBlockOffset:=1295);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PT-91
        // Device type: ICS_PT_mbar
        //********************************************

      "DEV_Spk-000CDL:Cryo-PT-91_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=572,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1327);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PT-92
        // Device type: ICS_PT_mbar
        //********************************************

      "DEV_Spk-000CDL:Cryo-PT-92_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=587,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1352);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PT-93
        // Device type: ICS_PT_mbar
        //********************************************

      "DEV_Spk-000CDL:Cryo-PT-93_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=602,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1377);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PT-94
        // Device type: ICS_PT_mbar
        //********************************************

      "DEV_Spk-000CDL:Cryo-PT-94_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=617,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1402);

        //********************************************
        // Device name: Spk-000CDL:Cryo-PT-95
        // Device type: ICS_PT_mbar
        //********************************************

      "DEV_Spk-000CDL:Cryo-PT-95_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=632,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1427);

        //********************************************
        // Device name: Spk-000CDL:Vac-VGC-071
        // Device type: ICS_PT_mbar
        //********************************************

      "DEV_Spk-000CDL:Vac-VGC-071_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=647,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1452);

        //********************************************
        // Device name: Spk-000CDL:Vac-VGP-070
        // Device type: ICS_PT_mbar
        //********************************************

      "DEV_Spk-000CDL:Vac-VGP-070_iDB" (EPICSToPLCLength:=15,
      EPICSToPLCDataBlockOffset:=662,
      PLCToEPICSLength:=25,
      PLCToEPICSDataBlockOffset:=1477);
END_FUNCTION
DATA_BLOCK "EPICS_DebuggerResult"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      EPICS_Debugger_UtilitiesCall : String;   // PLCFactory Utilities call status
      EPICS_Debugger_DeviceCalls : String;   // PLCFactory DeviceCalls status
      EPICS_Debugger_IOCHash : String;   // EPICS IOC Hash vs. PLCFactory Hash
      EPICS_Debugger_ModBusHeartBeat : String;   // EPICS IOC Modbus (IOC->PLC) communication status
      EPICS_Debugger_S7Connection : String;   // EPICS IOC S7 TCP (PLC->IOC) communication status
      EPICS_Debugger_EPICS_GeneralState : String;   // Main status of the EPICS IOC communication
      EPICS_S7Port : Int;   // Actual TCP port that has been opened by the PLC
      EPICS_ModbusPort : Int;   // Actual ModBusTCP port that has been opened by the PLC
      EPICS_PLC_EthernetInterface : UInt;   // The currently used HW Identifer of the Ethernet Port on the PLC dedicated to EPICS
      EPICS_PayloadSize_InBytes : UInt;   // The currently configured payload size in bytes
      EPICS_PLC_Hash : DInt;   // The PLC Hash
      EPICS_PLCFactory_Version : String;   // The PLCFactory version that was used to generate the PLC code
      EPICS_CommunicationOK : Bool;   // Overall EPICS communication is OK
   END_VAR

BEGIN

END_DATA_BLOCK
FUNCTION_BLOCK "EPICS_DebuggerFB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      CheckUtilitiesTON {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      UtilSquareErrorTON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      CheckUtilitiesTON2 {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      UtilSquareErrorTON2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ModBus_TON {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      ModBus_wordsave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
   END_VAR
   VAR DB_SPECIFIC
      Helper_String { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      Helper_String_Array { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT Helper_String : Struct
         String_Maximal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;
         String_Actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;
         StringValueArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of Byte;
      END_STRUCT;
   END_VAR
   VAR 
      S7ConnTON {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
   END_VAR

   VAR_TEMP 
      AllOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      i : Int;
      ModBusOK : Bool;
      S7OK : Bool;
   END_VAR


BEGIN
	//Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
	//This block was generated by PLCFactory
	//Description: This FB checks the EPICS configuration and outputs the result into EPICS_DebuggerResult.

	//DO NOT Modify this block!!!

	//AllOK will be evaluated in this code and passed to the EPICS_CommunicationOK signal that can be used by the PLC logic
	#AllOK := TRUE;

	#CheckUtilitiesTON(IN:="Utilities".Square_100ms,
	                   PT:=T#200ms,
	                   Q=>#UtilSquareErrorTON);

	#CheckUtilitiesTON2(IN := NOT "Utilities".Square_100ms,
	                   PT := T#200ms,
	                   Q => #UtilSquareErrorTON2);


	#ModBus_TON(IN := #ModBus_wordsave = "EPICSToPLC"."Word"[2],
	            PT := T#5s);


     "EPICS_DebuggerResult".#EPICS_PayloadSize_InBytes := 3004;
     "EPICS_DebuggerResult".#EPICS_PLC_Hash := 457744924;
     "EPICS_DebuggerResult".#EPICS_PLCFactory_Version := 'fb3b582a9a66e37ff877560bc4f23ab7654f4230';

	IF ("Utilities".AlwaysOn = FALSE) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_UtilitiesCall := 'ERROR: FunctionBlock: "_UilitiesFB" is called with a wrong InstanceDB. Call it with the existing iDB named: "Utilities" AND check if the System Memory bits and the System Clock byte is enabled!';
         #AllOK := FALSE;
	ELSE
	    IF (#UtilSquareErrorTON OR #UtilSquareErrorTON2) THEN
	        "EPICS_DebuggerResult".#EPICS_Debugger_UtilitiesCall := 'ERROR: FunctionBlock: "_UilitiesFB" is called with a wrong InstanceDB. Call it with the existing iDB named: "Utilities" AND check if the System Memory bits and the System Clock byte is enabled!';
             #AllOK := FALSE;
	    ELSE
	        "EPICS_DebuggerResult".#EPICS_Debugger_UtilitiesCall := 'OK: EPICS Utilities works as expected.';
	        
	    END_IF;
	END_IF;
	    
	IF ("Utilities".EPICS_Device_calls_precessed) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_DeviceCalls := 'OK: "EPICS_device_calls" is called as expected.';
	ELSE
	    "EPICS_DebuggerResult".#EPICS_Debugger_DeviceCalls := 'ERROR: "EPICS_device_calls" is not called in OB1!';
         #AllOK := FALSE;
	END_IF;
	    
	IF (("EPICSToPLC"."Word"[0] = "PLCToEPICS"."Word"[0]) AND ("EPICSToPLC"."Word"[1] = "PLCToEPICS"."Word"[1])) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_IOCHash := 'OK: IOC and PLC hash are equal.';
	ELSE    
	    "EPICS_DebuggerResult".#EPICS_Debugger_IOCHash := 'ERROR: IOC and PLC hash are NOT equal!';
         #AllOK := FALSE;
	END_IF;

	IF (#ModBus_TON.Q) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_ModBusHeartBeat := 'ERROR: The IOC is not sending any HeartBeat via ModBus!';
         #AllOK := FALSE;
	    #ModBusOK := FALSE;
	ELSE
	    "EPICS_DebuggerResult".#EPICS_Debugger_ModBusHeartBeat := 'OK: ModBus HeartBeat is received as expected.';
	    #ModBusOK := TRUE;
	END_IF;

	#S7ConnTON(IN := NOT "_CommsPLC_EPICS_DB".SendDone, PT := T#3s);

	IF ("_CommsPLC_EPICS_DB".BytesToSend > 0) THEN
	    
	    IF (#S7ConnTON.Q) THEN
	        "EPICS_DebuggerResult".EPICS_Debugger_S7Connection := 'ERROR: EPICS S7 connection can not send Status variables!';
	        #S7OK := FALSE;
             #AllOK := FALSE;
	    ELSE
	        "EPICS_DebuggerResult".EPICS_Debugger_S7Connection := 'OK: EPICS S7 works as expected.';
	        #S7OK := TRUE;
	        
	    END_IF;
	ELSE
	    "EPICS_DebuggerResult".EPICS_Debugger_S7Connection := 'OK: EPICS S7 disabled, there is no Status variable to send.';
	    #S7OK := TRUE;
	END_IF;

	IF (#ModBusOK AND #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'OK. EPICS IOC communication is ONLINE.';
	END_IF;

	IF (#ModBusOK AND NOT #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'ERROR. ModBus seems to be working but S7 TCP is blocked. Try to check your PLC router IP.';
         #AllOK := FALSE;
	END_IF;

	IF (NOT #ModBusOK AND #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'ERROR. ModBus seems to be offline. Waiting for IOC to finish connecting to the PLC.';
         #AllOK := FALSE;
	END_IF;

	IF ( NOT #ModBusOK AND NOT #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'ERROR. Both ModBus and S7 TCP seems to be offline. Check if your IOC is running and if it is connected to the right PLC interface. Your HardwareID comes from CCDB!';
         #AllOK := FALSE;
	END_IF;

	"EPICS_DebuggerResult".EPICS_ModbusPort := "_CommsPLC_EPICS_DB".MBPort;
	"EPICS_DebuggerResult".EPICS_S7Port := "_CommsPLC_EPICS_DB".S7Port;
	"EPICS_DebuggerResult".EPICS_PLC_EthernetInterface :=  "_CommsPLC_EPICS_DB".InterfaceID;

	#ModBus_wordsave := "EPICSToPLC"."Word"[2];

	//Put the Overall result to the Globl DB
	"EPICS_DebuggerResult".EPICS_CommunicationOK := #AllOK;


END_FUNCTION_BLOCK
DATA_BLOCK "EPICS_DebuggerFB_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"EPICS_DebuggerFB"

BEGIN

END_DATA_BLOCK
ORGANIZATION_BLOCK "EPICS_DebuggerOB"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2020 by European Spallation Source, Lund
	//This block was generated by PLCFactory
	//Description: This OB is a cyclic OB called in every PLC cycle and EPICS_DebuggerFB checks the EPICS configuration.

	//DO NOT Modify this block!!!
	"EPICS_DebuggerFB_iDB"();


END_ORGANIZATION_BLOCK
TYPE "typeModul"
VERSION : 0.1
   STRUCT
      slotLaddr : HW_IO;   // Hardware ID of  module
      slotErrorState : Bool;   // error state of module
   END_STRUCT;

END_TYPE


TYPE "typeDevice"
VERSION : 0.1
   STRUCT
      laddr : HW_DEVICE;   // Logical address of a device or slave (system constant in HW configuration)
      "name" : String[50];   // Device name
      errorState : USInt;   // Status of the device 1=ok!, 2=faulty, 3=lost connection, 4=disabled, 12= was faulty, 13=was lost, 14=was disabled
      error : Bool;   // Signalizes an error in the device/slave
      nextDevice : Int;   // device number of next device
      actualConfiguredModules : Int;   // Actual number of configured modules in the device
      slot : Array[0..30] of "typeModul";   // slot informations
   END_STRUCT;

END_TYPE


TYPE "typeIoSystem"
VERSION : 0.1
   STRUCT
      ioSystemId : UInt;   // ID of  IO System
      ioSystemError : Bool;   // TRUE: if an error is occured in the assigned IO System
      firstDevice : Int := 0;   // device number (index) of first device in IO System
      lastDevice : Int := 0;   // device number (index) of last device IO System
      actualConfiguredDevices : Int := 0;   // Actual number of configured devices in the IO System
      device : Array[1..60] of "typeDevice";   // List of all devices in the IO System
   END_STRUCT;

END_TYPE

TYPE "typePlc"
VERSION : 0.1
   STRUCT
      actualConfiguredCentralModules : Int;   // Actual number of configured local modules
      errorState : Bool;   // Status of the device 1=ok!, 2=faulty, 3=lost connection, 4=disabled, 12= was faulty, 13=was lost, 14=was disabled
      slot : Array[1..30] of "typeModul";   // slot informations
   END_STRUCT;

END_TYPE



DATA_BLOCK "DiagnosticsData"
TITLE = Diagosis data DB
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : SIEMENS
FAMILY : Diagnose
NAME : '10'
VERSION : 0.1
NON_RETAIN
//The global data block contains the data structure of the IO system, the control, the devices with the modules and an error buffer.
   VAR 
      plc { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : "typePlc";   // diagnosis information PLC
      ioSystem { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[1..5] of "typeIoSystem";   // diagnosis information IO systems
   END_VAR


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "DiagStartupIoSystem"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT DB_SPECIFIC
      ioSystemHwId { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : HW_IOSYSTEM;   // This ID is representing the IO System (PN or DP), find the ID in the system constants
   END_VAR

   VAR_OUTPUT 
      status { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The return value of system function, where the last error occured
      instructionError { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Indicates in which system function the error occured: 1= DeviceStates PN , 2=GetName PN, 3=ModuleStates PN,  4=DeviceStates DP, 5= GetName DP. 6= ModuleStates DP
      errorIndex { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The last index of the respective loop, if an error occures
   END_VAR

   VAR_IN_OUT 
      ioSystem : "typeIoSystem";   // The diagnostics structure for one IO System
   END_VAR

   VAR 
      statActualConfiguredDevices { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int := 0;   // Actual number of devices in the PN IO System
      statGeoAddr {OriginalPartName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False';} : GEOADDR;   // Slot information
      statGeoLaddr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : HW_ANY;   // GEO2LOG hardware identifier
      statConfiguredDevices { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..1023] of Bool;   // Temporary storage of the return of "DeviceStates", to combine the states of the devices with numbers and names
      statExistingDevices { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..1023] of Bool;   // Temporary storage of the return of "DeviceStates", to combine the states of the devices with numbers and names
      statFaultyDevices { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..1023] of Bool;   // Temporary storage of the return of "DeviceStates", to combine the states of the divices with numbers and names
      statDisabledDevices { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..1023] of Bool;   // Storage of the status of all devices in the PN IO System --> State: Disabled
      statProblemDevices { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..1023] of Bool;   // Storage of the status of all devices in the PN IO System --> State: Problem
      statDeviceModuleStates { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..127] of Bool;   // Storage of the status of all modules in the PN Devices --> State: Problem
      instGetNameDevices {OriginalPartName := 'FB_806_S71500'; LibVersion := '1.3'; ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False';} : Get_Name;   // Instance of system function "GetName"
      statInitString { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String;   // Used to initialize the temporary string to convert into STRING[50]
      statFirstDevice { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : UInt;   // Station number of the first device of the list
      statFirstDeviceFlag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool := TRUE;   // Help tag for the first device in the linked list
      statLastDevice { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : UInt;   // Station number of the last device of the list
      statLinkedListPointer { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The actual index pointer of the linked list (Actual pointer = Station number of the device)
      statFirstRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool := TRUE;   // Signalizes the first run
      statResetStatesOld { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Detect a rising edge at ResetStates
      statMaxDevices { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
   END_VAR

   VAR_TEMP 
      tempIndex : Int;   // index configured devices
      tempSlotIndex : Int;   // Loop index
      tempModuleNum : Int;   // index module number
      tempRetValGeo : Int;   // GEO2LOG error information
      tempRetValDeviceStates : Int;   // DeviceStates error information
      tempRetValModuleStates : Int;   // Return value system function ModuleStates
      tempStringConvert : String;   // Store the device names temporary here, to convert them into STRING[50]
      tempLastDevice : UInt;   // Temporary storage of the actual index, if it is the last device --> store it in static
      tempIoSystemError : Bool;
   END_VAR

   VAR CONSTANT 
      STATE_CONFIGURED : USInt := 1;   // Used for instruction DeviceStates, read out all configured devices
      STATE_FAULTY : USInt := 2;   // Used for instruction DeviceStates, read out all faulty devices
      STATE_DISABLED : USInt := 3;   // Used for instruction DeviceStates, read out all disabled devices
      STATE_EXIST : USInt := 4;   // Used for instruction DeviceStates, read out all devices not reachable
      STATE_PROBLEM : USInt := 5;   // Used for instruction DeviceStates, read out all devices with several problems
      DEVICE_SLAVE : USInt := 2;   // GEO2LOG structure: HW type = 2
      MODULE_OF_DEVICE : USInt := 4;   // GEO2LOG structure: HW type = 4
      IO_SYSTEM_AREA : USInt := 1;   // GEO2LOG structure: Area = 1
      DP_SYSTEM_AREA : USInt := 2;   // GEO2LOG structure: Area = 2
      ERR_DEV_STATE_DEVICES : USInt := 1;   // Identifies the instruction behind the error code of output "Status" --> DeviceStates PN (Configured, faulty, existing)
      ERR_GET_NAME_DEVICES : USInt := 2;   // Identifies the instruction behind the error code of output "Status" -->  GetName of devices PN
      ERR_MOD_STAT_DEVICES : USInt := 3;   // Identifies the instruction behind the error code of output "Status" --> ModuleStates PN
      ERR_DEV_STAT_PN : USInt := 1;   // Value for output instruction error, DeviceStates PN devices
      ERR_MOD_STAT_PN : USInt := 4;   // Value for output instruction error, ModuleStates PN devices
      MAX_SLAVES_DP : Int := 127;
      MAX_SLAVES_PN : Int := 127;
   END_VAR


BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Determine hardware identifier and module states from 
	//               PN or DP IO system
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29.08.2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	
	// The startup will be executed only once --> initialize the first run
	// indicator.
	#statFirstDeviceFlag := TRUE;
	#statFirstRun := TRUE;
	#statActualConfiguredDevices := 0;
	#statFirstDevice := 1;
	#statLastDevice := 1;
	
	//=============================================================================
	// CONFIGURED DEVICES
	//=============================================================================
	// Find out how much devices are configured in the IO System --> PROFINET IO
	// This number is the maximum number of devices, which will be checked in the
	// following programm
	#tempRetValDeviceStates := DeviceStates(LADDR := #ioSystemHwId,
	                                        MODE := #STATE_CONFIGURED,
	                                        STATE := #statConfiguredDevices);
	
	// Check if the block call was successful
	IF (#tempRetValDeviceStates <> 0)
	THEN
	    // Error handling
	    #status := #tempRetValDeviceStates;
	    #instructionError := #ERR_DEV_STATE_DEVICES;
	    // Call ok --> store the actual number of configured devices    
	ELSE
	    ;
	END_IF;
	
	//=============================================================================
	// EXISTING DEVICES
	//=============================================================================
	#tempRetValDeviceStates := DeviceStates(LADDR := #ioSystemHwId,
	                                        MODE := #STATE_EXIST,
	                                        STATE := #statExistingDevices);
	
	// Check if the block call was successful
	IF (#tempRetValDeviceStates <> 0)
	THEN
	    // Error handling
	    #status := #tempRetValDeviceStates;
	    #instructionError := #ERR_DEV_STATE_DEVICES;
	    // Call ok --> store the actual number of configured devices    
	ELSE
	    ;
	END_IF;
	
	//=============================================================================
	// FAULTY DEVICES
	//=============================================================================
	#tempRetValDeviceStates := DeviceStates(LADDR := #ioSystemHwId,
	                                        MODE := #STATE_FAULTY,
	                                        STATE := #statFaultyDevices);
	
	// Check if the block call was successful
	IF (#tempRetValDeviceStates <> 0)
	THEN
	    // Error handling
	    #status := #tempRetValDeviceStates;
	    #instructionError := #ERR_DEV_STATE_DEVICES;
	    // Call ok --> store the actual number of configured devices    
	ELSE
	    ;
	END_IF;
	
	// Find out the number of the assigned IO system, to define if it is
	// a PN or DP Network
	#tempRetValGeo := LOG2GEO(LADDR := #ioSystemHwId,
	                          GEOADDR := #statGeoAddr);
	
	// set IO system ID
	#ioSystem.ioSystemId := #statGeoAddr.IOSYSTEM;
	
	// Inilize the structure for system function GEO2LOG
	#statGeoAddr.HWTYPE := #DEVICE_SLAVE;   // Hardware type 2: IO device
	// Predefine the type OF IO system. Either Profinet IO or Profibus DP
	IF ((#statGeoAddr.IOSYSTEM >= 100)
	    AND (#statGeoAddr.IOSYSTEM <= 115))
	THEN
	    #statGeoAddr.AREA := #IO_SYSTEM_AREA;   // Area ID 1: PROFINET IO
	    #statMaxDevices := #MAX_SLAVES_PN;
	ELSIF ((#statGeoAddr.IOSYSTEM >= 1)
	    AND (#statGeoAddr.IOSYSTEM <= 32))
	THEN
	    #statGeoAddr.AREA := #DP_SYSTEM_AREA;   // Area ID 1: Profibus DP
	    #statMaxDevices := #MAX_SLAVES_DP;
	ELSE
	    ;
	END_IF;
	
	// Go trough all devices and get the status of the configured
	FOR #tempIndex := 1 TO #statMaxDevices DO
	    // The devices are configured --> Read out the logical address and the
	    // device name
	    IF (#statConfiguredDevices[#tempIndex] = TRUE)
	    THEN
	        // Increment the actual configured devices, store the state and
	        // HW_ID as an numerical value (UINT)
	        #statActualConfiguredDevices := #statActualConfiguredDevices + 1;
	        
	        // Store the first configured device for the linked list
	        IF (#statFirstDeviceFlag = TRUE)
	        THEN
	            #statFirstDevice := INT_TO_UINT(#tempIndex);
	            #ioSystem.firstDevice := UINT_TO_INT(#statFirstDevice);
	            #statFirstDeviceFlag := FALSE;
	            #tempLastDevice := INT_TO_UINT(#tempIndex);
	            // It is not the first bit --> Store the actual index as "next device"
	            // in the further one!
	        ELSE
	            #ioSystem.device[#tempLastDevice].nextDevice := #tempIndex;
	            #tempLastDevice := INT_TO_UINT(#tempIndex);
	        END_IF;
	        // Store the index of the last device for the exit condition of the
	        // followiing instructions
	        #statLastDevice := #tempLastDevice;
	        #ioSystem.lastDevice := UINT_TO_INT(#statLastDevice);
	        
	        // Station number 
	        #statGeoAddr.STATION := INT_TO_UINT(#tempIndex);
	        // read LADDR from devices
	        #tempRetValGeo := GEO2LOG(GEOADDR := #statGeoAddr,
	                                  LADDR => #statGeoLaddr);
	        // Everything is ok!
	        IF (#tempRetValGeo = 0)
	        THEN
	            // store LADDR from devices in diagnostic data block
	            #ioSystem.device[#tempIndex].laddr := #statGeoLaddr;
	            
	            // Store the device name, if the device is existing
	            // Get name is an acyclic instruction. In the startup OB, the
	            // instruction has to be repeated until it is done or error
	            REPEAT
	                // Get device name of each decive in PN System
	                #instGetNameDevices(LADDR := #ioSystemHwId,
	                                    STATION_NR := #statGeoAddr.STATION,
	                                    DATA := #tempStringConvert);
	                
	            UNTIL (#instGetNameDevices.DONE = TRUE)
	                OR (#instGetNameDevices.ERROR = TRUE)
	            END_REPEAT;
	            
	            IF (#instGetNameDevices.ERROR = TRUE)
	            THEN
	                // Error handling
	                #status := WORD_TO_INT(#instGetNameDevices.STATUS);
	                #instructionError := #ERR_GET_NAME_DEVICES;
	                #errorIndex := #tempIndex;
	                
	                // Everything is ok --> Convert the String[254] into String[50]    
	            ELSIF (#instGetNameDevices.DONE = TRUE)
	            THEN
	                // Cut all characters more than 50 to reduce the string length
	                #ioSystem.device[#tempIndex].name := DELETE(IN := #tempStringConvert,
	                                                            L := 204,
	                                                            P := 50);
	                
	                // Initialize the temporary string before next loop
	                #tempStringConvert := #statInitString;
	            ELSE
	                ;
	            END_IF;
	        ELSE
	            // If the return value ist not = 0 --> the device/system/module is
	            // not configured --> No error handling
	            // set LADDR from devices to 0 in diagnostic data block
	            #ioSystem.device[#tempIndex].laddr := 0;
	            #ioSystem.device[#tempIndex].name := '';
	        END_IF;
	        
	        // Check if the configured devices are faulty or lost once through
	        // the startup!
	        IF (#statExistingDevices[#tempIndex] = TRUE)
	        THEN
	            IF (#statFaultyDevices[#tempIndex] = TRUE)
	            THEN
	                
	                #ioSystem.device[#tempIndex].errorState := 2;
	                #ioSystem.device[#tempIndex].error := TRUE;
	                
	                // The device is not faulty and does exist --> set state ok!    
	            ELSE
	                #ioSystem.device[#tempIndex].errorState := 1;
	                #ioSystem.device[#tempIndex].error := FALSE;
	            END_IF;
	            // The connection to the device is lost at the moment    
	        ELSE
	            #ioSystem.device[#tempIndex].errorState := 3;
	            #ioSystem.device[#tempIndex].error := TRUE;
	        END_IF;
	        // No device is configured   
	    ELSE
	        ;
	    END_IF;
	    
	END_FOR;
	// Store the actual configured devices in the diagnostics structure
	#ioSystem.actualConfiguredDevices := #statActualConfiguredDevices;
	
	// Mark parameter "Next Device" of the last device in the list
	// --> "Next Device" = negative --> Last device in the list
	#ioSystem.device[#statLastDevice].nextDevice := -1;
	
	// Go through the devices until the last device is reached
	// If there are gaps between the device-list, jump over and have a look on
	// the "NextDevice" parameter
	REPEAT
	    IF (#statFirstRun = TRUE)
	    THEN
	        // The index of the linked list is representing the station number.
	        #statGeoAddr.STATION := #statFirstDevice;
	        // Initialize the pointer for the first run 
	        #statLinkedListPointer := UINT_TO_INT(#statFirstDevice);
	        // Reset the flag, which signalizes the first run.
	        #statFirstRun := FALSE;
	    ELSE
	        // The index of the linked list is representing the station number.
	        #statGeoAddr.STATION := INT_TO_UINT(#statLinkedListPointer);
	    END_IF;
	    
	    //=============================================================================
	    // Get the logical address of all modules and store the actual number of
	    // modules from each device
	    //=============================================================================
	    
	    // Inilize the structure for system function GEO2LOG
	    #statGeoAddr.HWTYPE := #MODULE_OF_DEVICE;   // Hardware type 4: Module
	    FOR #tempModuleNum := 0 TO 30 DO
	        // Slot number
	        #statGeoAddr.SLOT := INT_TO_UINT(#tempModuleNum);
	        // read LADDR from modules
	        #tempRetValGeo := GEO2LOG(GEOADDR := #statGeoAddr,
	                                  LADDR => #statGeoLaddr);
	        // check Retval
	        IF (#tempRetValGeo = 0)
	        THEN
	            // store LADDR from modules in diagnostic data block
	            #ioSystem.device[#statLinkedListPointer].slot[#tempModuleNum].slotLaddr := #statGeoLaddr;
	            #ioSystem.device[#statLinkedListPointer].actualConfiguredModules := #ioSystem.device[#statLinkedListPointer].actualConfiguredModules + 1;
	        ELSE
	            // If the return value ist not = 0 --> the device/system/module is
	            // not configured --> No error handling
	            // set LADDR from modules to 0 in diagnostic data block
	            #ioSystem.device[#statLinkedListPointer].slot[#tempModuleNum].slotLaddr := 0;
	        END_IF;
	    END_FOR;
	    
	    //=============================================================================
	    // Check modules of faulty Devices
	    //=============================================================================
	    
	    // Check the state of the configured devices
	    IF (#ioSystem.device[#statLinkedListPointer].errorState = 2)
	    THEN
	        // The device is reachable, but faulty because of an error in a
	        // subordinated system --> check the modules
	        #tempRetValModuleStates := ModuleStates(LADDR := #ioSystem.device[#statLinkedListPointer].laddr,
	                                                MODE := #STATE_PROBLEM,
	                                                STATE := #statDeviceModuleStates);
	        
	        IF (#tempRetValModuleStates <> 0)
	        THEN
	            // Error hanlding
	            #status := #tempRetValModuleStates;
	            #instructionError := #ERR_MOD_STAT_DEVICES;
	            #errorIndex := UINT_TO_INT(#statFirstDevice);
	        ELSE
	            // Store the state of the different module in the diag DB
	            FOR #tempSlotIndex := 0 TO #ioSystem.device[#statFirstDevice].actualConfiguredModules DO
	                IF (#statDeviceModuleStates[#tempSlotIndex + 1] = TRUE)
	                THEN
	                    #ioSystem.device[#statLinkedListPointer].slot[#tempSlotIndex].slotErrorState := TRUE;
	                ELSE
	                    #ioSystem.device[#statLinkedListPointer].slot[#tempSlotIndex].slotErrorState := FALSE;
	                END_IF;
	            END_FOR;
	        END_IF;
	    ELSIF (#ioSystem.device[#statLinkedListPointer].errorState = 3)
	    THEN
	        
	        FOR #tempSlotIndex := 0 TO #ioSystem.device[#statLinkedListPointer].actualConfiguredModules DO
	            IF (#ioSystem.device[#statLinkedListPointer].slot[#tempSlotIndex].slotLaddr <> 0)
	            THEN
	                #ioSystem.device[#statLinkedListPointer].slot[#tempSlotIndex].slotErrorState := TRUE;
	            END_IF;
	        END_FOR;
	        
	    ELSE
	        ; // no faulty device --> nothing to do!
	    END_IF;
	    
	    // Initialize the pointer for the next run
	    #statLinkedListPointer := #ioSystem.device[#statLinkedListPointer].nextDevice;
	    // If the last device is reached, reset the bit for the first run
	    //#FirstRun := TRUE;
	    // Checking the modules is done, the last device is reached
	UNTIL (#statLinkedListPointer < 0)
	END_REPEAT;
	// Reset the condition for the first run.
	#statFirstRun := TRUE;
	
	
END_FUNCTION_BLOCK

DATA_BLOCK "DiagStartupIoSystem_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"DiagStartupIoSystem"

BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "DiagStartupPlc"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_OUTPUT 
      status { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The return value of system function, where the last error occured
      instructionError { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Indicates in which system function the error occured: 1= DeviceStates PN , 2=GetName PN, 3=ModuleStates PN,  4=DeviceStates DP, 5= GetName DP. 6= ModuleStates DP
   END_VAR

   VAR_IN_OUT 
      plc { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : "typePlc";   // The diagnostics structure for one PLC
   END_VAR

   VAR 
      statGeoAddr {OriginalPartName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False';} : GEOADDR;   // Slot information
      statGeoLaddr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : HW_ANY;   // GEO2LOG hardware identifier
      statActualCentralModules { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : USInt := 0;   // Actual number of modules in the central station (PLC)
      statPlcModuleStates { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..127] of Bool;   // Storage of the status of all modules in the PLC central station --> State: Problem
   END_VAR

   VAR_TEMP 
      tempModuleNum : Int;   // index module number
      tempRetValGeo : Int;   // GEO2LOG error information
      tempRetValModuleStates : Int;   // Return value system function ModuleStates
   END_VAR

   VAR CONSTANT 
      MODULE_OF_PLC : USInt := 4;   // GEO2LOG structure: HW type = 4
      CPU : USInt := 0;   // GEO2LOG structure: Area = 0
      CENTRAL_SYSTEM : USInt := 0;   // GEO2LOG structure: IO System = 0
      CENTRAL_STATION : USInt;   // GEO2LOG structure: Station = 0
      HW_ID_PLC_MODULES : HW_DEVICE := 32;   // HW ID of the PLC, which is needed for getting the module states --> fix value
      STATE_PROBLEM : USInt := 5;   // Used for instruction DeviceStates, read out all devices with several problems
      ERR_MOD_STAT_CENTRAL : USInt := 3;   // Value for output instruction error, ModuleStates local modules
   END_VAR


BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Determine hardware identifier and module states from local
	//               modules
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29.08.2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	
	//=============================================================================
	// Determine hardware identifier from LOCAL MODULES
	//=============================================================================
	#statGeoAddr.HWTYPE := #MODULE_OF_PLC;      // Hardware type 4: module
	#statGeoAddr.AREA := #CPU;                  // Area ID 0: CPU
	#statGeoAddr.IOSYSTEM := #CENTRAL_SYSTEM;   // PROFINET IO system
	                                            // (0 = central unit in the rack)
	#statGeoAddr.STATION := #CENTRAL_STATION;   // Number of the rack
	                                            // if area identifier
	                                            //  AREA = 0 (central module).
	
	FOR #tempModuleNum := 1 TO 30 DO
	  // Slot number
	  #statGeoAddr.SLOT := INT_TO_UINT(#tempModuleNum);
	  // read LADDR from local modules
	  #tempRetValGeo := GEO2LOG(GEOADDR := #statGeoAddr,
	                            LADDR => #statGeoLaddr);
	  // check Retval
	  IF (#tempRetValGeo = 0)
	  THEN
	    // store LADDR from local modules in diagnostic data block
	    #plc.slot[#tempModuleNum].slotLaddr := #statGeoLaddr;
	    #statActualCentralModules := #statActualCentralModules + 1;
	  ELSE
	    // If the return value ist not = 0 --> the device/system/module is not
	    // configured --> No error handling
	    // set LADDR from local modules to 0 in diagnostic data block
	    #plc.slot[#tempModuleNum].slotLaddr := 0;
	  END_IF;
	  // Store the actual configured devices in the diagnostics DB
	  #plc.actualConfiguredCentralModules := #statActualCentralModules;
	END_FOR;
	
	
	//=============================================================================
	// Check module states from LOCAL MODULES
	//=============================================================================
	// Check if central module are available - at least one module is always
	// configured, the PLC itself
	IF (#plc.actualConfiguredCentralModules > 1)
	THEN
	  // Check the status of the local modules
	  #tempRetValModuleStates := ModuleStates(LADDR := #HW_ID_PLC_MODULES,
	                                          MODE := #STATE_PROBLEM,
	                                          STATE := #statPlcModuleStates);
	  
	  // Check if the block call was successful
	  IF (#tempRetValModuleStates <> 0)
	  THEN
	    // Error handling
	    #status := #tempRetValModuleStates;
	    #instructionError := #ERR_MOD_STAT_CENTRAL;
	  ELSE
	    ; // Everything is ok!
	  END_IF;
	ELSE
	  ; // There are no central module configured
	END_IF;
	
	// The error LED of the PLC is flashing --> Set error state of the PLC
	#plc.errorState := TRUE;
	
	
	//=============================================================================
	// set module states from LOCAL MODULES
	//=============================================================================
	
	// If the first bit in the array is true, at least one module is faulty
	IF (#statPlcModuleStates[0] = TRUE)
	THEN
	  // Check which of the modules are faulty
	  // PLC modules array starts at index 2 for the first local module
	  FOR #tempModuleNum := 2 TO #plc.actualConfiguredCentralModules + 1 DO
	    IF (#statPlcModuleStates[#tempModuleNum] = TRUE)
	    THEN
	      #plc.slot[#tempModuleNum - 1].slotErrorState := TRUE;
	    ELSE
	      #plc.slot[#tempModuleNum - 1].slotErrorState := FALSE;
	    END_IF;
	  END_FOR;
	  
	ELSE
	  // Everything is ok!
	  FOR #tempModuleNum := 1 TO #plc.actualConfiguredCentralModules DO
	    #plc.slot[#tempModuleNum].slotErrorState := FALSE;
	  END_FOR;
	  
	END_IF;
	
END_FUNCTION_BLOCK


DATA_BLOCK "DiagStartupPlc_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"DiagStartupPlc"

BEGIN

END_DATA_BLOCK

FUNCTION "DiagnosticError" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ioState : Word;   // IO state of the HW object
      laddr : HW_ANY;   // Hardware identifier
      channel : UInt;   // Channel number
      multiError : Bool;   // =true if more than one error is present
   END_VAR

   VAR_IN_OUT 
      plc : "typePlc";   // The diagnostics structure for one PLC
      ioSystem : Array[1..5] of "typeIoSystem";   // The diagnostics structure for one IO System
   END_VAR

   VAR_TEMP 
      tempGeoAddr {OriginalPartName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   // Geographical address of the disturbed Module / Device
      tempIoSystemIndex : Int;   // Index for IO System
      index : Int;   // index system
      tempRetVal : Int;   // Return value of LOG2GEO
   END_VAR

   VAR CONSTANT 
      GOOD : Word := 16#0001;   // Status of the hardware object: Bit 0: Good
      AREA_CENTRAL : UInt := 0;   // Area ID for PLC
      AREA_PROFINET : UInt := 1;   // Area ID for PROFINET IO
      AREA_PROFIBUS : UInt := 2;   // Area ID for PROFIBUS DP
   END_VAR


BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Evaluate Diagnostic interrupt OB information for PLC and
	//               devices
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29-08-2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	
	//=============================================================================
	// determine geographic address of faulty device
	//=============================================================================
	#tempRetVal := LOG2GEO(LADDR := #laddr,
	                       GEOADDR := #tempGeoAddr);
	
	
	//=============================================================================
	// evaluate diagnosis information for devices in an IO system
	//=============================================================================
	IF (#tempGeoAddr.AREA = #AREA_PROFINET)
	    OR (#tempGeoAddr.AREA = #AREA_PROFIBUS)
	THEN
	    
	    //=============================================================================
	    // determine index for IO system
	    //=============================================================================
	    FOR #index := 1 TO 5 DO
	        IF ("DiagnosticsData".ioSystem[#index].ioSystemId = #tempGeoAddr.IOSYSTEM)
	        THEN
	            #tempIoSystemIndex := #index;
	        END_IF;
	    END_FOR;
	    
	    IF (#tempIoSystemIndex <= 5)
	        AND (#tempGeoAddr.STATION <= 30)
	        AND (#tempGeoAddr.SLOT <= 30)
	    THEN
	        // evaluate diagnosis information IO system
	        IF (#ioState = #GOOD)
	        THEN
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].error := FALSE;
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempGeoAddr.SLOT].slotErrorState := FALSE;
	            
	            IF (#ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState = 2)
	            THEN
	                #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 12;
	            ELSIF (#ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState = 3)
	            THEN
	                #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 13;
	            ELSE
	                #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 1;
	            END_IF;
	        ELSE
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].error := TRUE;
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 2;
	            
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempGeoAddr.SLOT].slotErrorState := TRUE;
	        END_IF;
	        
	        
	    END_IF;
	    
	    //=============================================================================
	    // evaluate diagnosis information for PLC
	    //=============================================================================
	ELSIF (#tempGeoAddr.AREA = #AREA_CENTRAL)
	THEN
	    
	    IF (#tempGeoAddr.SLOT <= 30)
	    THEN
	        // evaluate diagnosis information PLC
	        IF (#ioState = #GOOD)
	        THEN
	            #plc.slot[#tempGeoAddr.SLOT].slotErrorState := FALSE;
	        ELSE
	            #plc.slot[#tempGeoAddr.SLOT].slotErrorState := TRUE;
	        END_IF;
	        
	    END_IF;
	    
	ELSE
	    ;
	END_IF;
	
END_FUNCTION

FUNCTION "PullOrPlugModules" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      laddr : HW_IO;   // Hardware identifier
      eventClass : Byte;   // 16#38/39: module inserted, removed
      faultId : Byte;   // Fault identifier
   END_VAR

   VAR_IN_OUT 
      plc : "typePlc";   // The diagnostics structure for one PLC
      ioSystem : Array[1..5] of "typeIoSystem";   // The diagnostics structure for one IO System
   END_VAR

   VAR_TEMP 
      tempIoSystemIndex : Int;   // Index for IO System
      index : Int;   // index system
      tempGeoAddr {OriginalPartName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   // Geographical address of the disturbed Module / Device
      tempRetVal : Int;   // Return value of LOG2GEO
   END_VAR

   VAR CONSTANT 
      AREA_CENTRAL : UInt := 0;   // Area ID for PLC
      AREA_PROFINET : UInt := 1;   // Area ID for PROFINET IO
      AREA_PROFIBUS : UInt := 2;   // Area ID for PROFIBUS DP
      MODULE_PLUGGED : Byte := 16#38;   // (Sub)module plugged
      MODULE_PULLED : Byte := 16#39;   // (Sub)module pulled or not responding
      MODULE_MATCHES : Byte := 16#54;   // IO submodule inserted and matches configured submodule
      MODULE_OK : Byte := 16#61;   // Module inserted, module type OK
   END_VAR


BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Evaluate Pull/plug interrupt OB information for PLC and
	//               devices
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29.08.2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	
	//=============================================================================
	// determine geographic address of faulty device
	//=============================================================================
	#tempRetVal := LOG2GEO(LADDR := #laddr,
	                       GEOADDR := #tempGeoAddr);
	
	//=============================================================================
	// evaluate diagnosis information for devices in an IO system
	//=============================================================================
	IF (#tempGeoAddr.AREA = #AREA_PROFINET)
	    OR (#tempGeoAddr.AREA = #AREA_PROFIBUS)
	THEN
	    
	    //=============================================================================
	    // determine index for IO system
	    //=============================================================================
	    FOR #index := 1 TO 5 DO
	        IF (#ioSystem[#index].ioSystemId = #tempGeoAddr.IOSYSTEM)
	        THEN
	            #tempIoSystemIndex := #index;
	        END_IF;
	    END_FOR;
	    
	    IF (#tempIoSystemIndex <= 5)
	        AND (#tempGeoAddr.STATION <= 30)
	        AND (#tempGeoAddr.SLOT <= 30)
	    THEN
	        // check modules plugged
	        IF (#eventClass = #MODULE_PLUGGED)
	        THEN
	            // reset error state only if the correct module is inserted
	            IF (#faultId = #MODULE_MATCHES)
	                OR (#faultId = #MODULE_OK)
	            THEN
	                #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].error := FALSE;
	                #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempGeoAddr.SLOT].slotErrorState := FALSE;
	                
	                IF (#ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState = 2)
	                THEN
	                    #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 12;
	                ELSIF (#ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState = 3)
	                THEN
	                    #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 13;
	                ELSE
	                    #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 1;
	                END_IF;
	            END_IF;
	            
	            // check modules pulled  
	        ELSIF (#eventClass = #MODULE_PULLED)
	        THEN
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].error := TRUE;
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 2;
	            
	            #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempGeoAddr.SLOT].slotErrorState := TRUE;
	            
	        ELSE
	            ;
	        END_IF;
	        
	        
	    END_IF;
	    
	    //=============================================================================
	    // evaluate diagnosis information for PLC
	    //=============================================================================
	ELSIF (#tempGeoAddr.AREA = #AREA_CENTRAL)
	THEN
	    
	    IF (#tempGeoAddr.SLOT <= 30)
	    THEN
	        IF (#eventClass = #MODULE_PLUGGED)
	        THEN
	            IF (#faultId = #MODULE_MATCHES)
	                OR (#faultId = #MODULE_OK)
	            THEN
	                #plc.slot[#tempGeoAddr.SLOT].slotErrorState := FALSE;
	            END_IF;
	            
	        ELSIF (#eventClass = #MODULE_PULLED)
	        THEN
	            #plc.slot[#tempGeoAddr.SLOT].slotErrorState := TRUE;
	        ELSE
	            ;
	        END_IF;
	        
	        
	    END_IF;
	    
	ELSE
	    ;
	END_IF;
	
END_FUNCTION

FUNCTION "RackOrStationFaliure" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      laddr : HW_DEVICE;   // Hardware identifier
      eventClass : Byte;   // Event class
      faultId : Byte;   // Fault identifier
   END_VAR

   VAR_IN_OUT 
      plc : "typePlc";   // The diagnostics structure for one PLC
      ioSystem : Array[1..5] of "typeIoSystem";   // The diagnostics structure for one IO System
   END_VAR

   VAR_TEMP 
      index : Int;   // index system
      tempSlotIndex : Int;   // Loop index
      tempIoSystemIndex : Int;   // Index for IO System
      tempGeoAddr {OriginalPartName := 'GEOADDR'; LibVersion := '1.0'} : GEOADDR;   // Geographical address of the disturbed Module / Device
      tempRetVal : Int;   // Return value of LOG2GEO
      tempRetValModuleStates : Int;   // Return value system function ModuleStates
      tempDeviceModuleStates : Array[0..127] of Bool;   // Storage of the status of all modules in the PN Devices --> State: Problem
      tempLaddr : HW_DEVICE;   // logical address of the disturbed Module / Device
   END_VAR

   VAR CONSTANT 
      AREA_CENTRAL : UInt := 0;   // Area ID for PLC
      AREA_PROFINET : UInt := 1;   // Area ID for PROFINET IO
      AREA_PROFIBUS : UInt := 2;   // Area ID for PROFIBUS DP
      SLAVE_DEVICE_RET : Byte := 16#38;   // return of a DP slave / IO device
      SLAVE_DEVICE_FAIL : Byte := 16#39;   // Failure of a DP slave / IO device
      DP_SLAVE_FAIL_RET : Byte := 16#C4;   // Failure/return of a DP slave
      IO_DEVICE_FAIL_RET : Byte := 16#CB;   // Failure/return of a PROFINET IO device
      STATE_PROBLEM : USInt := 5;   // Used for instruction DeviceStates, read out all devices with several problems
   END_VAR


BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Evaluate Rack/Station interrupt OB information for PLC and
	//               devices
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29.08.2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	
	//=============================================================================
	// determine geographic address of faulty device
	//=============================================================================
	#tempRetVal := LOG2GEO(LADDR := #laddr,
	                       GEOADDR := #tempGeoAddr);
	
	//=============================================================================
	// evaluate diagnosis information for devices in an IO system
	//=============================================================================
	IF (#tempGeoAddr.AREA = #AREA_PROFINET)
	  OR (#tempGeoAddr.AREA = #AREA_PROFIBUS)
	THEN
	  
	  //===========================================================================
	  // determine index for IO system
	  //===========================================================================
	  FOR #index := 1 TO 5 DO
	    IF (#ioSystem[#index].ioSystemId = #tempGeoAddr.IOSYSTEM)
	    THEN
	      #tempIoSystemIndex := #index;
	    END_IF;
	  END_FOR;
	    
	  IF (#tempIoSystemIndex <= 5)
	    AND (#tempGeoAddr.STATION <= 30)
	    AND (#tempGeoAddr.SLOT <= 30)
	  THEN
	    // check DP slave or IO device return 
	    IF (#eventClass = #SLAVE_DEVICE_RET)
	    THEN
	      // reset error state only if the slave or device state is OK
	      IF (#faultId = #DP_SLAVE_FAIL_RET)
	        OR (#faultId = #IO_DEVICE_FAIL_RET)
	      THEN
	        #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].error := FALSE;
	        
	        FOR #tempSlotIndex := 0 TO #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].actualConfiguredModules DO
	          #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempSlotIndex].slotErrorState := FALSE;
	        END_FOR;
	        
	        IF (#ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState = 2)
	        THEN
	          #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 12;
	        ELSIF (#ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState = 3)
	        THEN
	          #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 13;
	        ELSE
	          #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 1;
	        END_IF;
	        
	      ELSE
	        
	        // The device is reachable, but faulty because of an error in a
	        // subordinated system --> check the modules
	        #tempRetVal := GEO2LOG(LADDR => #tempLaddr,
	                               GEOADDR := #tempGeoAddr);
	        
	        #tempRetValModuleStates := ModuleStates(LADDR := #tempLaddr,
	                                                MODE := #STATE_PROBLEM,
	                                                STATE := #tempDeviceModuleStates);
	        
	        IF (#tempRetValModuleStates = 0)
	        THEN
	          // Store the state of the different module in the diag DB
	          FOR #tempSlotIndex := 0 TO #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].actualConfiguredModules DO
	            IF (#tempDeviceModuleStates[#tempSlotIndex + 1] = TRUE)
	            THEN
	              #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempSlotIndex].slotErrorState := TRUE;
	            ELSE
	              #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempSlotIndex].slotErrorState := FALSE;
	            END_IF;
	          END_FOR;
	        END_IF;
	        
	        #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 2;
	        
	      END_IF;
	      
	      // check DP slave or IO device failure 
	    ELSIF (#eventClass = #SLAVE_DEVICE_FAIL)
	    THEN
	      #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].error := TRUE;
	      #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].errorState := 3;
	      
	      FOR #tempSlotIndex := 0 TO #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].actualConfiguredModules DO
	        IF #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempSlotIndex].slotLaddr <> 0
	        THEN
	          #ioSystem[#tempIoSystemIndex].device[#tempGeoAddr.STATION].slot[#tempSlotIndex].slotErrorState := TRUE;
	        END_IF;
	      END_FOR;
	      
	    ELSE
	      ;
	    END_IF;
	    
	    
	  END_IF;
	
	//=============================================================================
	//evaluate diagnosis information for PLC
	//=============================================================================
	ELSIF (#tempGeoAddr.AREA = #AREA_CENTRAL)
	THEN
	  
	  IF (#tempGeoAddr.SLOT <= 30)
	  THEN
	    // check DP slave or IO device return 
	    IF (#eventClass = #SLAVE_DEVICE_RET)
	    THEN
	      IF (#faultId = #DP_SLAVE_FAIL_RET)
	        OR (#faultId = #IO_DEVICE_FAIL_RET)
	      THEN
	        #plc.slot[#tempGeoAddr.SLOT].slotErrorState := FALSE;
	      END_IF;
	      
	      // check DP slave or IO device failure 
	    ELSIF (#eventClass = #SLAVE_DEVICE_FAIL)
	    THEN
	      #plc.slot[#tempGeoAddr.SLOT].slotErrorState := TRUE;
	    ELSE
	      ;
	    END_IF;
	    
	    
	  END_IF;
	
	ELSE
	  ;
	END_IF;
	
END_FUNCTION

FUNCTION_BLOCK "Diagnostics"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      plc { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : "typePlc";   // The diagnostics structure for one PLC
      ioSystem { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[1..5] of "typeIoSystem";   // The diagnostics structure for one IO System
   END_VAR

   VAR 
      statIoSystemIndex { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Index for IO System
      statSlotIndex { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Index for Slot
      statDeviceIndex { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Index for Device
   END_VAR

   VAR_TEMP 
      retValLed : Int;
   END_VAR

   VAR CONSTANT 
      ERROR_LED : UInt := 2;   // Identification number of the ERROR LED
      ERROR_LED_ON : UInt := 4;   // LED status Color 1 flashing
   END_VAR


BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Basic diagnostic function that has to be called in every cycle
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29.08.2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	
	//=============================================================================
	// check error active
	//=============================================================================
	#retValLed := LED(LADDR := "Local~Common", LED := #ERROR_LED);
	IF #retValLed = #ERROR_LED_ON
	THEN
	    #plc.errorState := TRUE;
	ELSE
	    #plc.errorState := FALSE;
	END_IF;
	
	//=============================================================================
	// check error in IO systems active
	//=============================================================================
	FOR #statIoSystemIndex := 1 TO 5 DO
	    #ioSystem[#statIoSystemIndex].ioSystemError := FALSE;
	    
	    FOR #statDeviceIndex := 1 TO 60 DO
	        IF (#ioSystem[#statIoSystemIndex].device[#statDeviceIndex].error = TRUE)
	        THEN
	            #ioSystem[#statIoSystemIndex].ioSystemError := TRUE;
	        END_IF;
	    END_FOR;
	END_FOR;
	
	
	
END_FUNCTION_BLOCK

DATA_BLOCK "Diagnostics_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"Diagnostics"

BEGIN

END_DATA_BLOCK

ORGANIZATION_BLOCK "CyclicDiagnostics"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Main Cycle OB for diagnostics 
	//               OB type: Program cycle
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29-08-2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	
	
	"Diagnostics_iDB"(plc:="DiagnosticsData".plc,
	                  ioSystem:="DiagnosticsData".ioSystem);
	
END_ORGANIZATION_BLOCK


ORGANIZATION_BLOCK "Diagnostic error interrupt"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Diagnostics Error Interrupt OB
	//               OB type: Diagnostic Interrupt
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29-08-2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	//
	"DiagnosticError"(ioState:=#IO_State,
	                  laddr:=#LADDR,
	                  channel:=#Channel,
	                  multiError:=#MultiError,
	                  plc:="DiagnosticsData".plc,
	                  ioSystem:="DiagnosticsData".ioSystem);
	
END_ORGANIZATION_BLOCK

ORGANIZATION_BLOCK "Pull or plug of modules"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Pull or Plug of mudules OB
	//               OB type: Pull or Plug of devices
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29-08-2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	"PullOrPlugModules"(laddr:=#LADDR,
	                    eventClass:=#Event_Class,
	                    faultId:=#Fault_ID,
	                    plc:="DiagnosticsData".plc,
	                    ioSystem:="DiagnosticsData".ioSystem);
	
END_ORGANIZATION_BLOCK

ORGANIZATION_BLOCK "Rack or station failure"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality: Rack or Station faliure OB
	//               OB type: Rack or station failure
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code
	//        DON'T CHANGE THIS BLOCK MANUALY. Any changes will be overwritten in the next code generation.
	//
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29-08-2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	"RackOrStationFaliure"(laddr:=#LADDR,
	                       eventClass:=#Event_Class,
	                       faultId:=#Fault_ID,
	                       plc:="DiagnosticsData".plc,
	                       ioSystem:="DiagnosticsData".ioSystem);
	
END_ORGANIZATION_BLOCK

ORGANIZATION_BLOCK "Startup"
TITLE = "Complete Restart"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//=============================================================================
	//Author: SIEMENS, Owner: Miklos Boros
	//        email: borosmiklos@gmail.com; miklos.boros@esss.se
	//
	//Functionality:
	//        This OB is a Startup OB, it will be called after OB100 and before the main cycle.
	// 
	//
	//Please Note:
	//        This block is part of the generated ESS Standard Code however you should use 
	//        the proper ioSystem ID from the 
	//
	//Change log table:
	//Version  Date         Expert in charge      Changes applied
	//01.00.00 29.08.2017   ESS/ICS               First released version for PLCFactory 
	//02.00.00 09-04-2018   ESS/ICS               Major bug fix for PN/DP devices
	//=============================================================================
	
	//Initialize the Main PLC Diagnostic
	"DiagStartupPlc_iDB"(plc:="DiagnosticsData".plc);
	
	
	//Put your current IO device configuration here. HW identifiers are in the PLC Tags/System constants!
	//Initialize IOSystem1
	//"DiagStartupIoSystem_iDB"(ioSystemHwId:=268,
	//                          ioSystem:="DiagnosticsData".ioSystem[1]);
	
	
	
	
END_ORGANIZATION_BLOCK

DATA_BLOCK "EPICSToPLC"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
//########## EPICS->PLC datablock ##########
   STRUCT
      "Word" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..676] of Word;
   END_STRUCT;

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PLCToEPICS"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
//########## PLC->EPICS datablock ##########
   STRUCT
      "Word" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..1501] of Word;
   END_STRUCT;

BEGIN

END_DATA_BLOCK

FUNCTION "_CommsEPICS" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_TEMP
      PLC_Hash : DInt;
   END_VAR

BEGIN
	//Heartbeat PLC->EPICS
	IF "Utilities".Pulse_1s THEN
	    "PLCToEPICS"."Word"[2] := "PLCToEPICS"."Word"[2] + 1;
	    IF "PLCToEPICS"."Word"[2] >= 32000 THEN
	        "PLCToEPICS"."Word"[2] := 0;
	    END_IF;
	END_IF;

	// PLC Factory commit ID: fb3b582a9a66e37ff877560bc4f23ab7654f4230
	// PLC Hash (Generated by PLC Factory)
	#PLC_Hash := DINT#457744924;

	// Send the PLC Hash to the EPICS IOC
	"PLCToEPICS"."Word"[1] := DINT_TO_WORD(#PLC_Hash);
	"PLCToEPICS"."Word"[0] := DINT_TO_WORD(SHR(IN := #PLC_Hash, N := 16));

	// Send the PLC parameter upload status to the EPICS IOC
	"PLCToEPICS"."Word"[3] := "EPICSToPLC"."Word"[5];
     "Utilities".EPICSParametersStatus := "EPICSToPLC"."Word"[5];

	// Put the PLC Hash into the Modbus map
	"EPICSToPLC"."Word"[4] := DINT_TO_WORD(#PLC_Hash);
	"EPICSToPLC"."Word"[3] := DINT_TO_WORD(SHR(IN := #PLC_Hash, N := 16));


	// Put the payload size (in bytes) into the Modbus map
	"EPICSToPLC"."Word"[6] := 3004;

	// Call the comms block to provide PLC<->EPICS comms
	"_CommsPLC_EPICS_DB"(Enable         := "Utilities".AlwaysOn,
	                     SendTrigger    := "Utilities".Pulse_200ms,
	                     BytesToSend    := 3004,
	                     InterfaceID    := 72,
	                     S7ConnectionID := 256,
	                     MBConnectionID := 255,
	                     S7Port         := 2000,
	                     MBPort         := 502,
	                     PLCToEPICSData := "PLCToEPICS"."Word",
	                     EPICSToPLCData := "EPICSToPLC"."Word");

END_FUNCTION
