from __future__ import division
from __future__ import absolute_import

""" Template Factory: EPICS printer """


__author__     = "Krisztian Loki"
__copyright__  = "Copyright 2017, European Spallation Source, Lund"
__license__    = "GPLv3"


import re

from . import PRINTER, TemplatePrinterException
from tf_ifdef import IfDefInternalError, SOURCE, VERBATIM, BLOCK, CMD_BLOCK, STATUS_BLOCK, BASE_TYPE, ANALOG_LIMIT



def printer():
    return [ (EPICS.name(), EPICS),
             (EPICS_TEST.name(), EPICS_TEST),
             (EPICS_OPC.name(), EPICS_OPC) ]




class EPICS_BASE(PRINTER):
    ## These are copied from interface_factory.__init__.py

    # Length: 2 words
    EPICSTOPLC_HASH       = 0
    # Length: 1 word
    EPICSTOPLC_HEARTBEAT  = 2
    # Length: 2 words
    EPICSTOPLC_READ_HASH  = 3
    # Length: 1 word
    EPICSTOPLC_UPLOADSTAT = 5
    # Length: 1 word
    EPICSTOPLC_READ_PAYLOAD_SIZE = 6

    # Length: 2 words
    PLCTOEPICS_HASH       = 0 * 2
    # Length: 1 word
    PLCTOEPICS_HEARTBEAT  = 2 * 2
    # Length: 1 word
    PLCTOEPICS_UPLOADSTAT = 3 * 2

    DISABLE_PV = "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR"

    DISABLE_TEMPLATE = """
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "{DISABLE_PV}")"""

    INPV_TEMPLATE  = """record({recordtype}, "{pv_name}")
{{{alias}
	field(SCAN, "I/O Intr")
	field(DTYP, "{dtyp}")
	field({inp_out}){pv_extra}
}}

"""

    OUTPV_TEMPLATE = """record({recordtype}, "{pv_name}")
{{{alias}
	field(DTYP, "{dtyp}")
	field({inp_out}){pv_extra}
}}

"""

    TEST_INPV_TEMPLATE = """record({recordtype}, "{pv_name}")
{{{alias}
	field(SCAN, "Event")
	field(EVNT, "{dtyp}"){pv_extra}
}}

"""

    TEST_OUTPV_TEMPLATE = """record({recordtype}, "{pv_name}")
{{{alias}{pv_extra}
}}

"""

    PLC_INFO_FIELDS = """
	info("plc_datablock", "{plc_datablock}")
	info("plc_variable", "{plc_variable}")"""


    UPLOAD_PARAMS = "UploadParametersS"

    LNKx    = [ '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' ]
    MAX_LNK = len(LNKx)


    def __init__(self, test = False):
        super(EPICS_BASE, self).__init__(comments = True, show_origin = True, preserve_empty_lines = True)

        self._nonprop_re = re.compile('^([^:]*:[^:]*:)(.*)')
        self._validity_pvs = dict()
        self._validity_calc_names = dict()
        self._gen_validity_pvs = set()

        self._fo_name    = 'A_UpldParamS{foc}-FO'
        self._params     = []
        self._last_param = None
        self._uploads    = []
        self._endianness = None


    #
    # HEADER
    #
    def header(self, output, **keyword_params):
        super(EPICS_BASE, self).header(output, **keyword_params)

        # Expand the disable PV
        self.DISABLE_PV = self.expand(self.DISABLE_PV)

        self.DEFAULT_INDISABLE_TEMPLATE = self.DISABLE_TEMPLATE.format(DISABLE_PV = self.DISABLE_PV)
        self.INDISABLE_TEMPLATE = self.DISABLE_TEMPLATE
        self.OUTDISABLE_TEMPLATE = self.DISABLE_TEMPLATE.format(DISABLE_PV = self.DISABLE_PV)

        epics_db_header = """
################################################################################
#
# This file was autogenerated by PLCFactory
# Please, DO NOT EDIT by hand!
#
#
# Branch of PLCFactory: {plcf_branch}
# Commit id of PLCFactory: {plcf_commit}
# Status of PLCFactory working copy: {plcf_status_string}
# Command line:
#
# {cmdline}
#
################################################################################

#
# This shows the module version that was 'required'
#
record(stringin, "{root_inst_slot}:ModVersionR")
{{
	field(DESC,	"Module version")
	field(DISP,	"1")
	field(VAL,	"$(MODVERSION=N/A)")
	field(PINI,	"YES")
}}

#
# This can be used to get the branch of PLCFactory that was used to generate this file
#
record(stringin, "{root_inst_slot}:PLCFBranchR")
{{
	field(DESC,	"Branch of PLCFactory")
	field(DISP,	"1")
#{plcf_branch}
	field(VAL,	"{plcf_branch_39}")
	field(PINI,	"YES")
	info("plcf_branch", "{plcf_branch}")
}}

#
# This can be used to get the exact same version of PLCFactory that was used to generate this file
#
record(stringin, "{root_inst_slot}:PLCFCommitR")
{{
	field(DESC,	"Commit hash of PLCFactory")
	field(DISP,	"1")
#{plcf_commit}
	field(VAL,	"{plcf_commit_39}")
	field(PINI,	"YES")
	info("plcf_commit", "{plcf_commit}")
}}

#
# This shows if the PLCFactory working copy was clean when this file was generated
#
record(bi, "{root_inst_slot}:PLCFStatusR")
{{
	field(DESC,	"Status of PLCFactory")
	field(DISP,	"1")
	field(ZNAM,	"Dirty")
	field(ONAM,	"Clean")
	field(VAL,	"{plcf_status}")
	field(PINI,	"YES")
}}

#
# These are used in DOL links
#
record(bi, "{root_inst_slot}:C1")
{{
	field(DESC,	"Constant 1")
	field(DISP,	"1")
	field(PINI,	"YES")
	field(VAL,	"1")
}}

record(longin, "{root_inst_slot}:C2")
{{
	field(DESC,	"Constant 2")
	field(DISP,	"1")
	field(PINI,	"YES")
	field(VAL,	"2")
}}
""".format(root_inst_slot  = self.root_inst_slot(),
           plcf_commit     = keyword_params.get("COMMIT_ID", "N/A"),
           plcf_commit_39  = keyword_params.get("COMMIT_ID", "N/A")[:39],
           plcf_status     = int(keyword_params.get("PLCF_STATUS", 0)),
           plcf_status_string = "Clean" if keyword_params.get("PLCF_STATUS", False) else "Dirty",
           plcf_branch     = self.plcf("ext.plcfactory_branch()"),
           plcf_branch_39  = self.plcf("ext.plcfactory_branch()")[:39],
           cmdline         = self.plcf("ext.plcfactory_cmdline()"))

        self._append(epics_db_header, output)

        return self


    def comment(self):
        return "#"


    def inpv_template(self, test = False, sdis = False, VALIDITY_PV = None):
        """
            Called by STATUS_BLOCK.pv_template()
        """
        if sdis:
            if VALIDITY_PV is None:
                return self.DEFAULT_INDISABLE_TEMPLATE
            return self.INDISABLE_TEMPLATE.format(DISABLE_PV = VALIDITY_PV)
        if test:
            return self.TEST_INPV_TEMPLATE
        return self.INPV_TEMPLATE


    def outpv_template(self, test = False, sdis = False, VALIDITY_PV = None):
        """
            Called by CMD_BLOCK.pv_template() or PARAM_BLOCK.pv_template()
        """
        if sdis:
            return self.OUTDISABLE_TEMPLATE
        if test:
            return self.TEST_OUTPV_TEMPLATE
        return self.OUTPV_TEMPLATE


    def _body_register_block_printer(self, block):
        if block is None:
            return

        block.register_printer(self)


    def _body_block(self, block, output):
        if block.is_status_block():
            comment = "PLC   -> EPICS status  "
        elif block.is_command_block():
            comment = "EPICS -> PLC commands  "
        elif block.is_parameter_block():
            comment = "EPICS -> PLC parameters"
        elif block.is_general_input_block():
            comment = "EPICS -> PLC general inputs"
        else:
            raise IfDefInternalError("Unsupported block type: " + block.type())

        block.set_endianness(self._endianness)

        self._append((block.source(), """
##########
########## {inst_slot} {dir} ##########
##########
""".format(inst_slot = self.raw_inst_slot(),
           dir = comment)))


    def _body_var(self, var, output):
        self._append(self._toEPICS(var))

        if isinstance(var, ANALOG_LIMIT):
            self._set_alarm_limit(var, output)

        if not var.is_parameter():
            return

        self._params.append(var)

        # Have to resolve PLCF# expressions _now_ otherwise we'd end up with root_inst_slot in footer()
        self._last_param = (var.fqpn(), self.expand(var.get_pv_field("FLNK")))


    def _body_source(self, var, output):
        self._append(var)


    def _body_end_param(self, if_def, output):
        if not self._params:
            return

        self._uploads.append("{}:{}".format(self.inst_slot(if_def), self.UPLOAD_PARAMS))

        self._gen_param_fanouts(self._params, self.inst_slot(if_def), output)


    def _body_end(self, if_def, output):
        """
        Runs at the end of _ifdef_body()
        """
        for pv_cond in if_def.external_validity_pvs().items():
            self._gen_validity_calc(pv_cond, output)


    def _set_alarm_limit(self, var, output):
        limit = """
record(ao, "{ilimiter}")
{{
	field(DESC, "Set alarm limit value")
	field(DOL,  "{limiter} CP")
	field(OUT,  "{limited}.{field}")
	field(OMSL, "closed_loop"){disable_template}
}}
""".format(limiter   = var.fqpn(),
           ilimiter  = self.create_pv_name("A_" + var.pv_name()),
           limited   = self.create_pv_name(var.limited_pv()),
           field     = var.limit_field(),
           disable_template = self.DEFAULT_INDISABLE_TEMPLATE)

        self._append(limit, output)


    def _get_validity_pv(self, var, output = None):
        """
        Return the name of the validity PV assigned to this PV or None if the default should be used
        As a side effect it generates the necessary helper PVs
        """
        validity_pv = self.expand(var.get_parameter("VALIDITY_PV", None))
        validity_condition = var.get_parameter("VALIDITY_CONDITION", None)

        exp_var_pv_name = var.fqpn()

        # If this is the PV that some other PVs validity is based on then generate a calcout PV
        # First check if the expanded PV name is already registered as a validity PV
        # we have to fall back to checking if this PV has a VALIDITY_CONDITION keyword because it might be assigned to other PVs we haven't seen yet
        # FIXME: This is not really optimal, since VALIDITY_CONDITION might be erroneously missing
        if exp_var_pv_name in self._validity_pvs or validity_condition is not None:
            self._gen_validity_calc(var, output)

            # Check (and ignore) if it depends on itself (happens when VALIDITY_PV is set with 'set_defaults()')
            # First check if VALIDITY_PV is specified without a prefix
            # fall back to checking if VALIDITY_PV was specified with a prefix
            if var.pv_name() == validity_pv or exp_var_pv_name == validity_pv:
                return None

        if validity_pv is None:
            return None

        # Check if name has the prefix by checking if it was already registered
        if validity_pv in self._validity_pvs:
            return self._validity_pvs[validity_pv]

        # Check if validity PV is defined in this interface definition file
        val_pv_var = self._if_def.has_pv(validity_pv, prefix = self.inst_slot(self._if_def) + ':')
        if val_pv_var is not None:
            # We have to expand the PV name
            validity_pv = self.create_pv_name(val_pv_var)

        validity_name = "{} MSS".format(self._gen_validity_name(validity_pv))
        self._validity_pvs[validity_pv] = validity_name

        return validity_name


    def _gen_validity_calc(self, var, output = None):
        """
        Generate the helper PVs for validity calculation
        """

        if output is None:
            output = self._output

        if not isinstance(var, tuple):
            # This is a class; i.e. a PLC variable
            vpv = var.fqpn()
            vcond = var.get_parameter("VALIDITY_CONDITION", None)
            if vcond is None:
                raise TemplatePrinterException("VALIDITY_CONDITION is not specified", IFDEF_SOURCE = var)
        else:
            # This is an external validity PV
            vpv = self.expand(var[0])
            if vpv in self._gen_validity_pvs:
                return
            vcond = var[1]

        # Accept True/False in quotes
        if isinstance(vcond, str):
            vcond = self.expand(vcond)
            if vcond.lower() == "true":
                vcond = True
            elif vcond.lower() == "false":
                vcond = False

        # Register the fact that this validity PV was taken care of
        self._gen_validity_pvs.add(vpv)
        helpernames = self._gen_validity_name(vpv, "vclc", "vinv", "vhsh")

        if vcond is True:
            vcond = "A"
        elif vcond is False:
            vcond = "!A"

        # Generate PV ("vclc") that calculates validity using the supplied condition expression
        self._append("""
record(calcout, "{vclc}")
{{
	field(DESC, "Calculate validity")
	field(INPA, "{vpv} CP")
	field(IVOA, "Set output to IVOV")
	field(CALC, "{vcond}")
	field(OUT,  "{vinv} PP")
}}
""".format(vclc  = helpernames[1],
           vpv   = vpv,
           vcond = vcond,
           vinv  = helpernames[2]), output)

        # Generate PV ("vinv") that becomes INVALID when "vclc" is False
        self._append("""
record(bi, "{vinv}")
{{
	field(DESC, "Becomes INVALID if zero")
	field(ZSV,  "INVALID")
	field(PINI, "YES")
	field(VAL,  "0")
	field(FLNK, "{vbi}.PROC CA")
}}
""".format(vinv = helpernames[2],
           vbi  = helpernames[0]), output)

        # Generate PV ("vhsh") that ensures that 'vbi' will be processed every time PLCHashCorrectR changes
        self._append("""
record(bi, "{vhsh}")
{{
	field(DESC, "Forward PLCHashCorrectR change to vbi")
	field(INP,  "{sdis} CP")
	field(FLNK, "{vbi}.PROC CA")
}}
""".format(vhsh = helpernames[3],
           sdis = self.DISABLE_PV,
           vbi  = helpernames[0]), output)

        # Generate PV ("vbi") that aggregates DISABLE_PV and "vinv"
        self._append("""
record(calc, "{vbi}")
{{
	field(DESC, "Aggregate PLCHashCorrectR and vinv")
	field(INPA, "{sdis}")
	field(INPB, "{vinv} MSS")
	field(CALC, "A")
}}
""".format(vbi  = helpernames[0],
           sdis = self.DISABLE_PV,
           vinv = helpernames[2]), output)


    def _gen_validity_name(self, name, *suffixes):
        """
        Generate validity helper PV names
        By default only the bi PV (that must be referenced in SDIS fields) is returned.
        If suffixes is specified then a list consisting of the bi and suffixes will be returned
        """
        try:
            return self._validity_calc_names[name]
        except KeyError:
            pass

        rematch = self._nonprop_re.match(name)
        try:
            ess_name = rematch.group(1)
        except AttributeError:
            raise TemplatePrinterException("Non ESS conformant device name: '{}'".format(name))
        prop = rematch.group(2)

        vbi = "{}A_{}vbi".format(ess_name, prop)

        if len(suffixes) == 0:
            return vbi

        pvs = [ vbi ]
        pvs.extend(map(lambda s: "{}A_{}{}".format(ess_name, prop, s), suffixes))

        return pvs


    def _gen_param_fanouts(self, param_list, inst_slot, output, footer = False):
        foc = 0
        lnk = 0

        for upload in param_list:
            if lnk == self.MAX_LNK:
                foc += 1
                self._append("""	field(FLNK, "{inst_slot}:{upload}")
}}
""".format(inst_slot = inst_slot,
           upload    = self._fo_name.format(foc = foc)), output)

                lnk = 0

            if lnk == 0:
                self._append("""record(fanout, "{inst_slot}:{upload}")
{{
""".format(inst_slot = inst_slot,
           upload    = self.UPLOAD_PARAMS if foc == 0 else self._fo_name.format(foc = foc)), output)

            self._append("""	field(LNK{lnk}, "{upload}")
""".format(lnk       = self.LNKx[lnk],
           upload    = upload if footer else upload.fqpn()), output)

            lnk += 1

        if footer and foc == 0 and lnk == 0:
            # Create an empty UploadParamsS if there are no parameters
            epics_db_footer = """
record(fanout, "{inst_slot}:{upload}")
{{
""".format(inst_slot = inst_slot,
           upload    = self.UPLOAD_PARAMS)

            self._append(epics_db_footer, output)

        self._append("}", output)



    #
    # FOOTER
    #
    def footer(self, output, **keyword_params):
        super(EPICS_BASE, self).footer(output, **keyword_params)

        if not self._gen_validity_pvs == set(self._validity_pvs.keys()):
            raise TemplatePrinterException("The following validity PVs were not found or are missing VALIDITY_CONDITION:{}".format(set(self._validity_pvs.keys()) - self._gen_validity_pvs))

        self._gen_param_fanouts(self._uploads, self.root_inst_slot(), output, True)

        # Generate parameter uploading status monitoring
        self._append("""
record(bo, "{root_inst_slot}:A_InitUploadStat")
{{
	field(DESC, "Initialize parameter uploading status")
	field(DOL,  "{root_inst_slot}:C1")
	field(OMSL, "closed_loop")
	field(OUT,  "{root_inst_slot}:A_UploadStatToPLCS PP")

}}

record(longout, "{root_inst_slot}:A_DoneUploadStat")
{{
	field(DESC, "Done parameter uploading status")
	field(DOL,  "{root_inst_slot}:C2")
	field(OMSL, "closed_loop")
	field(OUT,  "{root_inst_slot}:A_UploadStatToPLCS PP")
}}

record(calcout, "{root_inst_slot}:A_AssertUploadStat")
{{
	field(DESC, "Assert validity of upload statistics")
	field(INPA, "{root_inst_slot}:UploadStat-RB CP")
	field(INPB, "{root_inst_slot}:A_InitUploadStat.UDF")
# PLC says we are uploading but A_InitUploadStat was never processed ==> reset upload status in the PLC
	field(CALC, "A == 1 && B == 1")
	field(OOPT, "When Non-zero")
	field(DOPT, "Use OCAL")
	field(OCAL, "0")
	field(OUT,  "{root_inst_slot}:A_UploadStatToPLCS PP")
}}
record(fanout, "{root_inst_slot}:{upload}")
{{
	field(LNK0, "{root_inst_slot}:A_InitUploadStat")
	field(SHFT, "0")
""".format(root_inst_slot = self.root_inst_slot(),
           upload         = self.UPLOAD_PARAMS), output)

        if self._last_param:
            if self._last_param[1]:
                # Very last parameter has custom FLNK
                self._append("""}}
record(fanout, "{root_inst_slot}:A_CustomFLNK")
{{
	field(LNK1, "{custom_flnk}")
	field(FLNK, "{root_inst_slot}:A_DoneUploadStat")
}}

record("*", "{last_param}")
{{
	field(FLNK, "{root_inst_slot}:A_CustomFLNK")
}}
""".format(root_inst_slot = self.root_inst_slot(),
           custom_flnk    = self._last_param[1],
           last_param     = self._last_param[0]), output)
            else:
                # No custom FLNK for very last parameter
                self._append("""}}

record("*", "{last_param}")
{{
	field(FLNK, "{root_inst_slot}:A_DoneUploadStat")
}}""".format(root_inst_slot = self.root_inst_slot(),
             last_param     = self._last_param[0]), output)
        else:
            # No parameters, append LNK1 to root_inst_slot:UploadParametersS
            self._append("""
	field(LNK1, "{root_inst_slot}:A_DoneUploadStat")
}}""".format(root_inst_slot = self.root_inst_slot()), output)




#
# EPICS output
#
class EPICS(EPICS_BASE):
    def __init__(self, test = False):
        super(EPICS, self).__init__(test)
        self._test   = test


    @staticmethod
    def name():
        return "EPICS-DB"


    def field_inp(self, inst_io, offset, dtyp_var_type, link_extra):
        """
            Called by STATUS_BLOCK.inp_out()
        """
        return '@{inst_io}/{offset} T={dtyp_var_type}{link_extra}'.format(inst_io       = inst_io,
                                                                          offset        = offset,
                                                                          dtyp_var_type = dtyp_var_type,
                                                                          link_extra    = link_extra)


    def field_out(self, inst_io, offset, dtyp_var_type, link_extra):
        """
            Called by COMMAND_BLOCK.inp_out() or PARAM_BLOCK.inp_out()
        """
        return '@{inst_io}($(PLCNAME)write, {offset}, {link_extra}){dtyp_var_type}'.format(inst_io       = inst_io,
                                                                                           offset        = offset,
                                                                                           dtyp_var_type = dtyp_var_type,
                                                                                           link_extra    = link_extra)


    def _toEPICS(self, var):
        pv_extra = var.pv_template(sdis = True, VALIDITY_PV = self._get_validity_pv(var)) + var.build_pv_extra() + EPICS_BASE.PLC_INFO_FIELDS.format(plc_datablock = self._if_def.datablock_name(),
                                                                                                           plc_variable  = var.name())
        if var.is_parameter() or self._test:
            pv_extra = pv_extra + """
	info(autosaveFields_pass0, "VAL")"""

        return (var.source(),
                var.pv_template(test = self._test).format(recordtype = var.pv_type(),
                                                          pv_name    = var.fqpn(),
                                                          alias      = var.build_pv_alias(),
                                                          dtyp       = var.dtyp(),
                                                          inp_out    = var.inp_out(inst_io       = var.inst_io(),
                                                                                   offset        = var.link_offset(self._plc_to_epics_offset, self._epics_to_plc_offset),
                                                                                   dtyp_var_type = var.endian_correct_dtyp_var_type(),
                                                                                   link_extra    = var.link_extra() + var._get_user_link_extra()),
                                                          pv_extra   = pv_extra))


    def _db_header(self, **keyword_params):
        return """

#########################################################
########## EPICS <-> PLC connection management ##########
#########################################################
record(asyn, "{root_inst_slot}:Asyn")
{{
	field(DTYP,	"asynRecordDevice")
	field(PORT,	"$(PLCNAME)")
}}
record(bi, "{root_inst_slot}:ModbusConnectedR")
{{
	field(DESC,	"Shows if the MODBUS channel connected")
	field(INP,	"{root_inst_slot}:Asyn.CNCT CP")
	field(ONAM,	"Connected")
	field(ZNAM,	"Disconnected")
	field(ZSV,      "MAJOR")
	field(FLNK,	"{root_inst_slot}:CommsHashToPLCS.PROC CA")
}}
record(bi, "{root_inst_slot}:S7ConnectedR")
{{
	field(DESC,	"Shows if the S7 channel is connected")
	field(SCAN,	"I/O Intr")
	field(DTYP,	"S7plc stat")
	field(INP,	"@$(PLCNAME)")
	field(ONAM,	"Connected")
	field(ZNAM,	"Disconnected")
	field(ZSV,      "MAJOR")
}}
record(stringin, "{root_inst_slot}:PLCAddr-RB")
{{
# We assume S7 and Modbus address are the same (as they should be)
	field(DESC,	"Address of the PLC")
}}
record(scalcout, "{root_inst_slot}:A_CalcPLCAddr")
{{
	field(DESC,	"Strip port number of host:port")
	field(INAA,	"{root_inst_slot}:S7Addr-RB CP")
	field(CALC,	"AA[0,':']")
	field(OUT,	"{root_inst_slot}:PLCAddr-RB PP")
}}
record(stringout, "{root_inst_slot}:PLCAddrS")
{{
	field(DESC,	"Set the address of the PLC")
	field(FLNK,	"{root_inst_slot}:A_SetPLCAddr-FO")
}}
record(fanout, "{root_inst_slot}:A_SetPLCAddr-FO")
{{
	field(LNK1,	"{root_inst_slot}:A_CalcS7AddrS")
	field(LNK2,	"{root_inst_slot}:A_CalcModbusAddrS")
}}
record(scalcout, "{root_inst_slot}:A_CalcS7AddrS")
{{
	field(DESC,	"Construct the S7 address")
	field(INAA,	"{root_inst_slot}:PLCAddrS")
	field(CALC,	"AA + ':' + '$(S7_PORT)'")
	field(OUT,	"{root_inst_slot}:A_S7AddrS PP")
}}
record(scalcout, "{root_inst_slot}:A_CalcModbusAddrS")
{{
	field(DESC,	"Construct the Modbus address")
	field(INAA,	"{root_inst_slot}:PLCAddrS")
	field(CALC,	"AA + ':' + '$(MODBUS_PORT)'")
	field(OUT,	"{root_inst_slot}:Asyn.HOSTINFO PP")
}}
record(stringin, "{root_inst_slot}:ModbusAddr-RB")
{{
	field(DESC,	"Address of the PLC")
	field(INP,	"{root_inst_slot}:Asyn.HOSTINFO CP")
}}
record(stringin, "{root_inst_slot}:S7Addr-RB")
{{
	field(DESC,	"Address of the PLC")
	field(INP,	"{root_inst_slot}:A_S7AddrS CP")
}}
record(stringout, "{root_inst_slot}:A_S7AddrS")
{{
	field(DESC,	"Set address of the PLC")
	field(DTYP,	"S7plc addr")
	field(OUT,	"@$(PLCNAME)")
	field(DISP,	"1")
}}
record(calcout, "{root_inst_slot}:A_CalcConn")
{{
# Need to explicitly scan because using multiple CPs is not robust
	field(SCAN,	"1 second")
	field(INPA,	"{root_inst_slot}:S7ConnectedR CP")
	field(INPB,	"{root_inst_slot}:ModbusConnectedR CP")
	field(CALC,	"A && B")
	field(OUT,	"{root_inst_slot}:ConnectedR PP")
}}
record(bi, "{root_inst_slot}:ConnectedR")
{{
	field(DESC,	"Shows if the PLC is connected")
	field(ONAM,	"Connected")
	field(ZNAM,	"Disconnected")
	field(ZSV,      "MAJOR")
}}
record(bi, "{root_inst_slot}:PLCHashCorrectR")
{{
	field(DESC,	"Shows if the comms hash is correct")
	field(ONAM,	"Correct")
	field(ZNAM,	"Incorrect")
	field(ZSV,      "MAJOR")
}}
record(bi, "{root_inst_slot}:AliveR")
{{
	alias("{root_inst_slot}:CommsOK")
	field(DESC,	"Shows if the PLC is sending heartbeats")
	field(ONAM,	"Alive")
	field(ZNAM,	"Not responding")
	field(ZSV,      "MAJOR")
}}
record(bi, "{root_inst_slot}:PayloadSizeCorrectR")
{{
	field(DESC,	"Shows if the payload size is correct")
	field(ONAM,	"Correct")
	field(ZNAM,	"Incorrect")
	field(ZSV,      "MAJOR")
}}
record(calcout, "{root_inst_slot}:A_CheckHash")
{{
	field(INPA,	"{root_inst_slot}:CommsHashToPLC")
	field(INPB,	"{root_inst_slot}:A_HasMBHash")
	field(INPC,	"{root_inst_slot}:S7CommsHash")
	field(INPD,	"{root_inst_slot}:MBCommsHash")
	field(INPE,	"{root_inst_slot}:S7CommsHash.STAT")
	field(INPF,	"{root_inst_slot}:MBCommsHash.STAT")
# if we have the HASH in the modbus map it should be the same as the one from the S7 stream
	field(CALC,	"A == C && (B ? C == D : 1) && E == 0 && F == 0")
	field(OOPT,	"On Change")
	field(OUT,	"{root_inst_slot}:PLCHashCorrectR PP")
}}
record(bo, "{root_inst_slot}:A_GotHeartbeat")
{{
	field(DESC,	"Update AliveR")
	field(DOL,	"{root_inst_slot}:C1")
	field(OMSL,	"closed_loop")
	field(OUT,	"{root_inst_slot}:A_KickAlive PP")
}}
record(bo, "{root_inst_slot}:A_KickAlive")
{{
	field(DESC,	"Set AliveR to true for 2 seconds")
	field(HIGH,	"5")
	field(OUT,	"{root_inst_slot}:AliveR PP")
}}
record(mbbi, "{root_inst_slot}:UploadStat-RB")
{{
# Maintain compatibility with existing OPIs
	alias("{root_inst_slot}:UploadStatR")
	field(DESC,	"Parameter upload status from the PLC")
	field(SCAN,	"I/O Intr")
	field(DTYP,	"S7plc")
	field(INP,	"@$(PLCNAME)/{plc_to_epics_upload_stat} T=INT16")
	field(NOBT,     "16")
	field(SHFT,     "0")

	field(ZRVL,	"0")
	field(ZRST,	"Never uploaded")

	field(ONVL,	"1")
	field(ONST,	"Uploading...")

	field(TWVL,	"2")
	field(TWST,	"Uploaded")

	field(DISS,	"INVALID")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:PLCHashCorrectR")
}}
record(longin, "{root_inst_slot}:PayloadSizeR")
{{
	field(DESC,	"The configuread payload size")
	field(DISP,	"1")
	field(PINI,	"YES")
	field(VAL,	"${{PAYLOAD_SIZE=-1}}")
}}
record(calcout, "{root_inst_slot}:A_CheckPayloadSize")
{{
	field(INPA,	"{root_inst_slot}:PayloadSizeR")
	field(INPB,	"{root_inst_slot}:PayloadSizeFromPLCR")
	field(INPC,	"{root_inst_slot}:PayloadSizeFromPLCR.STAT")
	field(CALC,	"A == B && C == 0")
	field(OOPT,	"On Change")
	field(OUT,	"{root_inst_slot}:PayloadSizeCorrectR PP")
}}

########################################################
########## EPICS -> PLC comms management data ##########
########################################################
record(ao, "{root_inst_slot}:CommsHashToPLC")
{{
# Maintain compatibility with existing OPIs
	alias("{root_inst_slot}:iCommsHashToPLC")
	field(DESC,	"The comms hash to PLC")
	field(DISP,	"1")
	field(PINI,	"YES")
	field(VAL,	"#HASH")
}}
record(ao, "{root_inst_slot}:CommsHashToPLCS")
{{
	field(DESC,	"Sends comms hash to PLC")
	field(SCAN,	"1 second")
	field(DTYP,	"asynInt32")
	field(OUT,	"@asyn($(PLCNAME)write, {epics_to_plc_hash}, 100)INT32_{endianness}")
	field(OMSL,	"closed_loop")
	field(DOL,	"{root_inst_slot}:CommsHashToPLC")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:ModbusConnectedR")
}}
record(calc, "{root_inst_slot}:A_CalcHeartbeatToPLC")
{{
	field(SCAN,	"1 second")
	field(INPA,	"{root_inst_slot}:A_CalcHeartbeatToPLC.VAL")
	field(CALC,	"(A >= 32000)? 0 : A + 1")
	field(FLNK,	"{root_inst_slot}:HeartbeatToPLCS")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:ModbusConnectedR")
}}
record(ao, "{root_inst_slot}:HeartbeatToPLCS")
{{
	field(DESC,	"Sends heartbeat to PLC")
	field(DTYP,	"asynInt32")
	field(OUT,	"@asyn($(PLCNAME)write, {epics_to_plc_heartbeat}, 100)")
	field(OMSL,	"closed_loop")
	field(DOL,	"{root_inst_slot}:A_CalcHeartbeatToPLC.VAL")
	field(OIF,	"Full")
	field(DRVL,	"0")
	field(DRVH,	"32000")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:ModbusConnectedR")
}}
record(longout, "{root_inst_slot}:A_UploadStatToPLCS")
{{
	field(DESC,	"Parameter upload status to the PLC")
	field(DTYP,	"asynInt32")
	field(OUT,	"@asyn($(PLCNAME)write, {epics_to_plc_upload_stat}, 100)")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:ModbusConnectedR")
}}

########################################################
########## PLC -> EPICS comms management data ##########
########################################################
# This iS7CommsHash/iMBCommsHash/iIsMBHash magic is needed because moving the HASH to the modbus map
#  does not change the HASH itself so the new SCL is not necessarily downloaded to the PLC
# AND making sure that iS7CommsHash == iMBCommsHash is a good check to make sure that the size of
#  the S7 stream is correctly set
record(ai, "{root_inst_slot}:S7CommsHash")
{{
	field(DESC,	"Comms hash from PLC using S7 stream")
	field(SCAN,	"I/O Intr")
	field(DTYP,	"S7plc")
	field(INP,	"@$(PLCNAME)/{plc_to_epics_hash} T=INT32")
	field(FLNK,	"{root_inst_slot}:CommsHashFromPLCR")
}}
record(ai, "{root_inst_slot}:MBCommsHash")
{{
	field(DESC,	"Comms hash from PLC using MB map")
	field(SCAN,	"I/O Intr")
	field(DTYP,	"asynInt32")
	field(INP,	"@asyn($(PLCNAME)read, {epics_to_plc_read_hash}, 100)INT32_{endianness}")
	field(FLNK,	"{root_inst_slot}:A_HasMBHash")
}}
record(calcout, "{root_inst_slot}:A_HasMBHash")
{{
	field(INPA,	"{root_inst_slot}:MBCommsHash")
	field(CALC,	"A != 0")
# Make sure to process it even if it is being processed right now
	field(OUT,	"{root_inst_slot}:CommsHashFromPLCR.PROC CA")
}}
record(sel, "{root_inst_slot}:CommsHashFromPLCR")
{{
	field(DESC,	"Comms hash from PLC")
	field(NVL,	"{root_inst_slot}:A_HasMBHash")
	field(INPA,	"{root_inst_slot}:S7CommsHash MSS")
	field(INPB,	"{root_inst_slot}:MBCommsHash MSS")
	field(FLNK,	"{root_inst_slot}:A_CheckHash")
}}
record(ai, "{root_inst_slot}:HeartbeatFromPLCR")
{{
	field(DESC,	"Heartbeat from PLC")
	field(SCAN,	"I/O Intr")
	field(DTYP,	"S7plc")
	field(INP,	"@$(PLCNAME)/{plc_to_epics_heartbeat} T=INT16")
	field(FLNK,	"{root_inst_slot}:A_GotHeartbeat")
	field(DISS,	"INVALID")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:PLCHashCorrectR")
}}
record(longin, "{root_inst_slot}:PayloadSizeFromPLCR")
{{
	field(DESC,	"Payload size from PLC using MB map")
	field(SCAN,	"I/O Intr")
	field(DTYP,	"asynInt32")
	field(INP,	"@asyn($(PLCNAME)read, {epics_to_plc_read_payload_size}, 100)INT16")
	field(FLNK,	"{root_inst_slot}:A_CheckPayloadSize")
}}

""".format(root_inst_slot  = self.root_inst_slot(),
           endianness      = self._endianness,
           epics_to_plc_hash              = self.EPICSToPLCDataBlockStartOffset + self.EPICSTOPLC_HASH,
           epics_to_plc_heartbeat         = self.EPICSToPLCDataBlockStartOffset + self.EPICSTOPLC_HEARTBEAT,
           epics_to_plc_read_hash         = self.EPICSTOPLC_READ_HASH,
           epics_to_plc_upload_stat       = self.EPICSToPLCDataBlockStartOffset + self.EPICSTOPLC_UPLOADSTAT,
           plc_to_epics_hash              = self.PLCToEPICSDataBlockStartOffset + self.PLCTOEPICS_HASH,
           plc_to_epics_heartbeat         = self.PLCToEPICSDataBlockStartOffset + self.PLCTOEPICS_HEARTBEAT,
           plc_to_epics_upload_stat       = self.PLCToEPICSDataBlockStartOffset + self.PLCTOEPICS_UPLOADSTAT,
           epics_to_plc_read_payload_size = self.EPICSTOPLC_READ_PAYLOAD_SIZE)


    #
    # HEADER
    #
    def header(self, output, **keyword_params):
        super(EPICS, self).header(output, **keyword_params).add_filename_header(output, extension = "db")

        self.get_endianness()

        self.get_offsets()

        self._append(self._db_header(**keyword_params), output)

        self.advance_offsets_after_header()

        return self


    #
    # BODY
    #
    def _ifdef_body(self, if_def, output, **keyword_params):
        self._output = output

        self._body_register_block_printer(if_def._cmd_block())
        self._body_register_block_printer(if_def._param_block())
        self._body_register_block_printer(if_def._gen_input_block())
        self._body_register_block_printer(if_def._status_block())

        self._append("""
##########
########## {inst_slot} ##########
##########
""".format(inst_slot = self.raw_inst_slot()))
        self._body_verboseheader(if_def._cmd_block(), output)
        self._body_verboseheader(if_def._param_block(), output)
        self._body_verboseheader(if_def._gen_input_block(), output)
        self._body_verboseheader(if_def._status_block(), output)

        self._append("""##########

""")

        self._params = []
        for src in if_def.interfaces():
            if isinstance(src, BLOCK):
                self._body_block(src, output)
            elif isinstance(src, BASE_TYPE):
                self._body_var(src, output)
            elif isinstance(src, VERBATIM):
                self._append((src.source(), str(src)))
            elif isinstance(src, SOURCE):
                self._body_source(src, output)
            else:
                self._append(self._toEPICS(src))

        self._body_end_param(if_def, output)
        self._append("\n\n")
        self._body_end_epics_to_plc(if_def, output)
        self._body_end_plc_to_epics(if_def, output)

        self._body_end(if_def, output)


    def _body_end_epics_to_plc(self, if_def, output):
        self._epics_to_plc_offset += int(if_def.to_plc_words_length())


    def _body_end_plc_to_epics(self, if_def, output):
        # S7 offsets are in bytes
        self._plc_to_epics_offset += 2 * int(if_def.from_plc_words_length())


    def _body_verboseheader(self, block, output):
        if block is None or self._test:
            return

        self._append("########## {keyword}: {length}\n".format(keyword = block.length_keyword(), length = block.length() // 2))




class EPICS_TEST(EPICS):
    def __init__(self):
        super(EPICS_TEST, self).__init__(test = True)


    @staticmethod
    def name():
        return "EPICS-TEST-DB"


    def _db_header(self, **keyword_params):
        return """

#########################################################
########## EPICS <-> PLC connection management ##########
#########################################################
record(bi, "{root_inst_slot}:ModbusConnectedR")
{{
	field(DESC,	"Shows if the MODBUS channel connected")
	field(ONAM,	"Connected")
	field(ZNAM,	"Disconnected")
	field(ZSV,      "MAJOR")
	field(VAL,	"1")
	field(PINI,	"YES")
	field(FLNK,	"{root_inst_slot}:CommsHashToPLCS")
}}
record(bi, "{root_inst_slot}:S7ConnectedR")
{{
	field(DESC,	"Shows if the S7 channel is connected")
	field(ONAM,	"Connected")
	field(ZNAM,	"Disconnected")
	field(ZSV,      "MAJOR")
	field(VAL,	"1")
	field(PINI,	"YES")
}}
record(calcout, "{root_inst_slot}:A_CalcConn")
{{
# Need to explicitly scan because using multiple CPs is not robust
	field(SCAN,	"1 second")
	field(INPA,	"{root_inst_slot}:S7ConnectedR CP")
	field(INPB,	"{root_inst_slot}:ModbusConnectedR CP")
	field(CALC,	"A && B")
	field(OUT,	"{root_inst_slot}:ConnectedR PP")
}}
record(bi, "{root_inst_slot}:ConnectedR")
{{
	field(DESC,	"Shows if the PLC is connected")
	field(ONAM,	"Connected")
	field(ZNAM,	"Disconnected")
	field(ZSV,      "MAJOR")
}}
record(event, "{root_inst_slot}:A_Event")
{{
	field(DESC,	"Generate S7plc event")
	field(SCAN,	".2 second")
	field(VAL,	"S7plc")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:S7ConnectedR")
}}
record(bi, "{root_inst_slot}:PLCHashCorrectR")
{{
	field(DESC,	"Shows if the comms hash is correct")
	field(ONAM,	"Correct")
	field(ZNAM,	"Incorrect")
	field(ZSV,      "MAJOR")
}}
record(bi, "{root_inst_slot}:AliveR")
{{
	alias("{root_inst_slot}:CommsOK")
	field(DESC,	"Shows if the PLC is sending heartbeats")
	field(ONAM,	"Alive")
	field(ZNAM,	"Not responding")
	field(ZSV,      "MAJOR")
}}
record(calcout, "{root_inst_slot}:A_CheckHash")
{{
	field(INPA,	"{root_inst_slot}:CommsHashToPLC")
	field(INPB,	"{root_inst_slot}:CommsHashFromPLCR")
	field(INPC,	"{root_inst_slot}:CommsHashFromPLCR.STAT")
	field(CALC,	"A == B && C == 0")
	field(OOPT,	"On Change")
	field(OUT,	"{root_inst_slot}:PLCHashCorrectR PP")
}}
record(bo, "{root_inst_slot}:A_GotHeartbeat")
{{
	field(DESC,	"Update AliveR")
	field(DOL,	"{root_inst_slot}:C1")
	field(OMSL,	"closed_loop")
	field(OUT,	"{root_inst_slot}:A_KickAlive PP")
}}
record(bo, "{root_inst_slot}:A_KickAlive")
{{
	field(DESC,	"Set AliveR to true for 2 seconds")
	field(HIGH,	"2")
	field(OUT,	"{root_inst_slot}:AliveR PP")
}}
record(longin, "{root_inst_slot}:UploadStat-RB")
{{
	field(DESC,	"Parameter upload status from the PLC")
	field(DISS,	"INVALID")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:PLCHashCorrectR CP")
	info(autosaveFields_pass0, "VAL")
}}

########################################################
########## EPICS -> PLC comms management data ##########
########################################################
record(ao, "{root_inst_slot}:CommsHashToPLC")
{{
# Maintain compatibility with existing OPIs
	alias("{root_inst_slot}:iCommsHashToPLC")
	field(DISP,	"1")
	field(PINI,	"YES")
	field(VAL,	"#HASH")
}}
record(ao, "{root_inst_slot}:CommsHashToPLCS")
{{
	field(DESC,	"Sends comms hash to PLC")
	field(OMSL,	"closed_loop")
	field(DOL,	"{root_inst_slot}:CommsHashToPLC")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:ConnectedR")
}}
record(calc, "{root_inst_slot}:A_CalcHeartbeatToPLC")
{{
	field(SCAN,	"1 second")
	field(INPA,	"{root_inst_slot}:A_CalcHeartbeatToPLC.VAL")
	field(CALC,	"(A >= 32000)? 0 : A + 1")
	field(FLNK,	"{root_inst_slot}:HeartbeatToPLCS")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:ConnectedR")
}}
record(ao, "{root_inst_slot}:HeartbeatToPLCS")
{{
	field(DESC,	"Sends heartbeat to PLC")
	field(OMSL,	"closed_loop")
	field(DOL,	"{root_inst_slot}:A_CalcHeartbeatToPLC.VAL")
	field(OIF,	"Full")
	field(DRVL,	"0")
	field(DRVH,	"32000")
}}
record(longout, "{root_inst_slot}:A_UploadStatToPLCS")
{{
	field(DESC,	"Parameter upload status to the PLC")
	field(OUT,	"{root_inst_slot}:UploadStat-RB PP")
	field(DISV,	"0")
	field(SDIS,	"{root_inst_slot}:ConnectedR")
}}

########################################################
########## PLC -> EPICS comms management data ##########
########################################################
record(ai, "{root_inst_slot}:CommsHashFromPLCR")
{{
	field(DESC,	"Comms hash from PLC")
	field(SCAN,	"1 second")
	field(PINI,	"YES")
	field(VAL,	"#HASH")
	field(FLNK,	"{root_inst_slot}:A_CheckHash")
}}
record(ai, "{root_inst_slot}:HeartbeatFromPLCR")
{{
	field(DESC,	"Heartbeat from PLC")
	field(INP,	"{root_inst_slot}:A_CalcHeartbeatToPLC.VAL CP")
	field(FLNK,	"{root_inst_slot}:A_GotHeartbeat")
}}

########################################################
################# Test management data #################
########################################################
record(ao, "{root_inst_slot}:FixHashS")
{{
	field(DESC,	"Make HASH correct")
	field(OMSL,	"closed_loop")
	field(DOL,	"{root_inst_slot}:CommsHashToPLC")
	field(OUT,	"{root_inst_slot}:CommsHashFromPLCR PP")
}}

record(bo, "{root_inst_slot}:RuinHashS")
{{
	field(DESC,	"Make HASH incorrect")
	field(FLNK,	"{root_inst_slot}:A_RuinHash")
}}
record(calcout, "{root_inst_slot}:A_RuinHash")
{{
	field(DESC,	"Make HASH incorrect")
	field(INPA,	"{root_inst_slot}:CommsHashToPLC")
	field(CALC,	"A * -1")
	field(OUT,	"{root_inst_slot}:CommsHashFromPLCR PP")
}}
""".format(root_inst_slot = self.root_inst_slot())



#
# OPC-UA EPICS output
#
class EPICS_OPC(EPICS_BASE):
    def __init__(self):
        super(EPICS_OPC, self).__init__()


    @staticmethod
    def name():
        return "EPICS-OPC-DB"


    def field_inp(self, inst_io, datablock, var_name, **keyword_params):
        return '@{inst_io} ns=3;s=\\"{datablock}\\".\\"{var_name}\\"'.format(inst_io    = inst_io,
                                                                             datablock  = datablock,
                                                                             var_name   = var_name)


    def field_out(self, inst_io, datablock, var_name, monitor = " monitor=n"):
        return '@{inst_io} ns=3;s=\\"{datablock}\\".\\"{var_name}\\"{monitor}'.format(inst_io    = inst_io,
                                                                                      datablock  = datablock,
                                                                                      var_name   = var_name,
                                                                                      monitor    = monitor)


    def _toEPICS(self, var):
        pv_extra = self.DISABLE_TEMPLATE + var.build_pv_extra() + EPICS_BASE.PLC_INFO_FIELDS.format(plc_datablock = var.datablock_name(),
                                                                                                    plc_variable  = var.name())
        return (var.source(),
                var.pv_template().format(recordtype = var.pv_type(),
                                         pv_name    = var.fqpn(),
                                         alias      = var.build_pv_alias(),
                                         dtyp       = "OPCUA",
                                         inp_out    = var.inp_out(inst_io   = '$(SUBSCRIPTION)',
                                                                  datablock = var.datablock_name(),
                                                                  var_name  = var.name()),
                                         pv_extra   = pv_extra))


    #
    # HEADER
    #
    def header(self, output, **keyword_params):
        # This is intentional but check if it is possible to call super(EPICS_OPC, self).header
        PRINTER.header(self, output, **keyword_params).add_filename_header(output, extension = "db")

        # Expand the disable PV
        self.DISABLE_PV = self.expand(self.DISABLE_PV)
        self.DISABLE_TEMPLATE = EPICS_OPC.DISABLE_TEMPLATE.format(DISABLE_PV = self.DISABLE_PV)

        epics_db_header = """
record(stringin, "{root_inst_slot}:ModVersionR")
{{
	field(DISP,	"1")
	field(VAL,	"$(MODVERSION=N/A)")
	field(PINI,	"YES")
}}

record(stringin, "{root_inst_slot}:PLCFCommitR")
{{
	field(DISP,	"1")
#{plcf_commit}
	field(VAL,	"{plcf_commit_39}")
	field(PINI,	"YES")
	info("plcf_commit", "{plcf_commit}")
}}

record(mbbi, "{root_inst_slot}:OPCStateR")
{{
	field(DTYP, "OPCUA")
	field(INP, "@$(SUBSCRIPTION) i=2259")
	field(ZRST, "Running")
	field(ONST, "Failed")
	field(TWST, "NoConfiguration")
	field(THST, "Suspended")
	field(FRST, "Shutdown")
	field(FVST, "Test")
	field(SXST, "CommunicationFault")
	field(SVST, "Unknown")
}}

record(ao, "{root_inst_slot}:CommsHashToPLC")
{{
# Maintain compatibility with existing OPIs
	alias("{root_inst_slot}:iCommsHashToPLC")
	field(DISP,	"1")
	field(PINI,	"YES")
	field(VAL,	"#HASH")
}}
record(ao, "{root_inst_slot}:CommsHashToPLCS")
{{
	field(DESC,	"Sends comms hash to PLC")
#	field(SCAN,	"1 second")
	field(OMSL,	"closed_loop")
	field(DOL,	"{root_inst_slot}:CommsHashToPLC")
}}
""".format(root_inst_slot  = self.root_inst_slot(),
           plcf_commit     = keyword_params.get("COMMIT_ID", "N/A"),
           plcf_commit_39  = keyword_params.get("COMMIT_ID", "N/A")[:39])

        self._append(epics_db_header, output)
        return self


    #
    # BODY
    #
    def _ifdef_body(self, if_def, output, **keyword_params):
        self._output = output

        self._body_register_block_printer(if_def._cmd_block())
        self._body_register_block_printer(if_def._param_block())
        self._body_register_block_printer(if_def._gen_input_block())
        self._body_register_block_printer(if_def._status_block())

        self._append("""
##########
########## {inst_slot} ##########
##########

""".format(inst_slot = self.raw_inst_slot()))

        self._params = []
        for src in if_def.interfaces():
            if isinstance(src, BLOCK):
                self._body_block(src, output)
            elif isinstance(src, BASE_TYPE):
                self._body_var(src, output)
            elif isinstance(src, VERBATIM):
                self._append((src.source(), str(src)))
            elif isinstance(src, SOURCE):
                self._body_source(src, output)
            else:
                self._append(self._toEPICS(src))

        self._body_end_param(if_def, output)
        self._append("\n\n")
