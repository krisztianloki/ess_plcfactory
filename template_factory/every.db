
##########
########## [PLCF#INSTALLATION_SLOT] ##########
##########
########## CommandWordsLength: 28
########## StatusWordsLength: 31
##########

#<<<--- define_status_block()

##########
########## [PLCF#INSTALLATION_SLOT] PLC   -> EPICS status   ##########
##########

#<<<--- add_digital("s_digital")
record(bi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_digital')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 0] T=UINT8 B=0")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_digital("s_digitala", PV_ALIAS=["s_digitalab", "s_digitalac", "s_digitalac12345678901234567890"])
record(bi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_digitala')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_digitalab')]")
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_digitalac')]")
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_digitalac12345678901234567890')]")

	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 0] T=UINT8 B=1")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}


#<<<--- add_analog("s_analogBYTE", "BYTE")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogBYTE')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 1] T=UINT8")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("s_analogBYTEa", "BYTE", PV_ALIAS="s_analogBYTEab")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogBYTEa')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogBYTEab')]")

	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 2] T=UINT8")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("s_analogINT", "INT")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogINT')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 4] T=INT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("s_analogDINT", "DINT")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogDINT')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 6] T=INT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("s_analogWORD", "WORD")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogWORD')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 10] T=UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("s_analogDWORD", "DWORD")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogDWORD')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 12] T=UINT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("s_analogREAL", "REAL")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_analogREAL')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 16] T=FLOAT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}


#<<<--- add_enum("s_enumBYTE", "BYTE")
record(mbbi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumBYTE')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 20] T=UINT8")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("s_enumBYTEa", "BYTE", PV_ALIAS="s_enumBYTEab")
record(mbbi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumBYTEa')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumBYTEab')]")

	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 21] T=UINT8")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("s_enumINT", "INT")
record(mbbi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumINT')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 22] T=INT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("s_enumDINT", "DINT")
record(mbbi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumDINT')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 24] T=INT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("s_enumWORD", "WORD")
record(mbbi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumWORD')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 28] T=UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("s_enumDWORD", "DWORD")
record(mbbi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumDWORD')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 30] T=UINT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("s_enumREAL", "REAL")
record(mbbi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_enumREAL')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 34] T=FLOAT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}


#<<<--- add_bitmask("s_bitmaskBYTE", "BYTE")
record(mbbiDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskBYTE')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 38] T=UINT8")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("s_bitmaskBYTEa", "BYTE", PV_ALIAS="s_bitmaskBYTEab")
record(mbbiDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskBYTEa')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskBYTEab')]")

	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 39] T=UINT8")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("s_bitmaskINT", "INT")
record(mbbiDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskINT')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 40] T=INT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("s_bitmaskDINT", "DINT")
record(mbbiDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskDINT')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 42] T=INT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("s_bitmaskWORD", "WORD")
record(mbbiDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskWORD')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 46] T=UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("s_bitmaskDWORD", "DWORD")
record(mbbiDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskDWORD')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 48] T=UINT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("s_bitmaskREAL", "REAL")
record(mbbiDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_bitmaskREAL')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 52] T=FLOAT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}


#<<<--- add_time("s_time")
record(ai, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_time')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 56] T=INT32")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(EGU,  "ms")
}


#<<<--- add_minor_alarm("s_minor", "Minor alarm")
record(bi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_minor')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 60] T=UINT16 B=0")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(ONAM, "Minor alarm")
	field(OSV,  "MINOR")
}

#<<<--- add_major_alarm("s_major", "Major alarm")
record(bi, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:s_major')]")
{
	field(SCAN, "I/O Intr")
	field(DTYP, "S7plc")
	field(INP,  "@$(PLCNAME)/[PLCF# ( ^(PLCToEPICSDataBlockStartOffset) + Counter2 ) * 2 + 60] T=UINT16 B=1")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(ONAM, "Major alarm")
	field(OSV,  "MAJOR")
}




#<<<--- define_command_block()

##########
########## [PLCF#INSTALLATION_SLOT] EPICS -> PLC commands   ##########
##########

#<<<--- add_digital("c_digital")
record(bo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_digital')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 0], 0x0001, 100)")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_digital("c_digitala", PV_ALIAS="c_digitalab")
record(bo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_digitala')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_digitalab')]")

	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 0], 0x0002, 100)")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}


#<<<--- add_analog("c_analogBYTE", "BYTE")
record(ao, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_analogBYTE')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 1], 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("c_analogBYTEa", "BYTE", PV_ALIAS="c_analogBYTEab")
record(ao, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_analogBYTEa')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_analogBYTEab')]")

	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 2], 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("c_analogINT", "INT")
record(ao, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_analogINT')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 3], 100)INT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("c_analogDINT", "DINT")
record(ao, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_analogDINT')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 4], 100)INT32_[PLCF#'BE' if '^(PLC-EPICS-COMMS:Endianness)' == 'BigEndian' else 'LE']")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#<<<--- add_analog("c_analogWORD", "WORD")
record(ao, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_analogWORD')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 6], 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}

#add_analog("c_analogDWORD", "DWORD")
#<<<--- add_analog("c_analogREAL", "REAL")
record(ao, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_analogREAL')]")
{
	field(DTYP, "asynFloat64")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 7], 100)FLOAT32_[PLCF#'BE' if '^(PLC-EPICS-COMMS:Endianness)' == 'BigEndian' else 'LE']")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
}


#<<<--- add_enum("c_enumBYTE", "BYTE")
record(mbbo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_enumBYTE')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 9], 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("c_enumBYTEa", "BYTE", PV_ALIAS="c_enumBYTEab")
record(mbbo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_enumBYTEa')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_enumBYTEab')]")

	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 10], 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("c_enumINT", "INT")
record(mbbo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_enumINT')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 11], 100)INT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("c_enumDINT", "DINT")
record(mbbo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_enumDINT')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 12], 100)INT32_[PLCF#'BE' if '^(PLC-EPICS-COMMS:Endianness)' == 'BigEndian' else 'LE']")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_enum("c_enumWORD", "WORD")
record(mbbo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_enumWORD')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 14], 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#add_enum("c_enumDWORD", "DWORD")
#<<<--- add_enum("c_enumREAL", "REAL")
record(mbbo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_enumREAL')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 15], 100)FLOAT32_[PLCF#'BE' if '^(PLC-EPICS-COMMS:Endianness)' == 'BigEndian' else 'LE']")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}


#<<<--- add_bitmask("c_bitmaskBYTE", "BYTE")
record(mbboDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_bitmaskBYTE')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 17], 0xFFFF, 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("c_bitmaskBYTEa", "BYTE", PV_ALIAS="c_bitmaskBYTEab")
record(mbboDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_bitmaskBYTEa')]")
{
	alias("[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_bitmaskBYTEab')]")

	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 18], 0xFFFF, 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("c_bitmaskINT", "INT")
record(mbboDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_bitmaskINT')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 19], 0xFFFF, 100)INT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("c_bitmaskDINT", "DINT")
record(mbboDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_bitmaskDINT')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 20], 0xFFFF, 100)INT32_[PLCF#'BE' if '^(PLC-EPICS-COMMS:Endianness)' == 'BigEndian' else 'LE']")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#<<<--- add_bitmask("c_bitmaskWORD", "WORD")
record(mbboDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_bitmaskWORD')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 22], 0xFFFF, 100)UINT16")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}

#add_bitmask("c_bitmaskDWORD", "DWORD")
#<<<--- add_bitmask("c_bitmaskREAL", "REAL")
record(mbboDirect, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_bitmaskREAL')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 23], 0xFFFF, 100)FLOAT32_[PLCF#'BE' if '^(PLC-EPICS-COMMS:Endianness)' == 'BigEndian' else 'LE']")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(NOBT, "16")
	field(SHFT, "0")
}


#<<<--- add_time("c_time")
record(ao, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_time')]")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 25], 100)INT32_[PLCF#'BE' if '^(PLC-EPICS-COMMS:Endianness)' == 'BigEndian' else 'LE']")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(EGU,  "ms")
}


#<<<--- add_minor_alarm("c_minor", "Minor alarm")
record(bo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_minor')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 27], 0x0001, 100)")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(ONAM, "Minor alarm")
	field(OSV,  "MINOR")
}

#<<<--- add_major_alarm("c_major", "Major alarm")
record(bo, "[PLCF#ext.check_pv_length('INSTALLATION_SLOT:c_major')]")
{
	field(DTYP, "asynUInt32Digital")
	field(OUT,  "@asynMask($(PLCNAME)write, [PLCF# ( ^(EPICSToPLCDataBlockStartOffset) + Counter1 ) + 27], 0x0002, 100)")
	field(DISS, "INVALID")
	field(DISV, "0")
	field(SDIS, "[PLCF#ROOT_INSTALLATION_SLOT]:PLCHashCorrectR")
	field(ONAM, "Major alarm")
	field(OSV,  "MAJOR")
}



#COUNTER Counter1 = [PLCF# Counter1 + 28]
#COUNTER Counter2 = [PLCF# Counter2 + 31]
